{
  "0": "const hasCloseElements = (numbers, threshold) => {\n  for (let idx = 0; idx < numbers.length; idx++) {\n    const elem = numbers[idx];\n    for (let idx2 = 0; idx2 < numbers.length; idx2++) {\n      if (idx !== idx2) {\n        const elem2 = numbers[idx2];\n        const distance = Math.abs(elem - elem2);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};",
  "1": "const separateParenGroups = (parenString) => {\n  const result = [];\n  let currentString = [];\n  let currentDepth = 0;\n\n  for (const c of parenString) {\n    if (c === '(') {\n      currentDepth += 1;\n      currentString.push(c);\n    } else if (c === ')') {\n      currentDepth -= 1;\n      currentString.push(c);\n\n      if (currentDepth === 0) {\n        result.push(currentString.join(''));\n        currentString = [];\n      }\n    }\n  }\n\n  return result;\n};",
  "2": "const truncate_number = (number) => {\n  return number % 1.0;\n};",
  "3": "const belowZero = (operations) => {\n  let balance = 0;\n\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n\n  return false;\n};",
  "4": "const meanAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;\n  return numbers.reduce((sum, num) => sum + Math.abs(num - mean), 0) / numbers.length;\n};",
  "5": "/**\n * @param {number[]} numbers\n * @param {number} delimeter\n * @return {number[]}\n */\nconst intersperse = (numbers, delimeter) => {\n    if (!numbers) {\n        return [];\n    }\n\n    const result = [];\n\n    for (let i = 0; i < numbers.length - 1; i++) {\n        result.push(numbers[i]);\n        result.push(delimeter);\n    }\n\n    if (numbers.length > 0) {\n        result.push(numbers[numbers.length - 1]);\n    }\n\n    return result;\n};",
  "6": "const parseNestedParens = (parenString) => {\n\n  const parseParenGroup = (s) => {\n    let depth = 0;\n    let maxDepth = 0;\n    for (const c of s) {\n      if (c === '(') {\n        depth++;\n        maxDepth = Math.max(depth, maxDepth);\n      } else {\n        depth--;\n      }\n    }\n    return maxDepth;\n  };\n\n  return parenString.split(' ').filter(x => x).map(x => parseParenGroup(x));\n};",
  "7": "const filterBySubstring = (strings, substring) => {\n  return strings.filter(str => str.includes(substring));\n};",
  "8": "const sum_product = (numbers) => {\n\n  let sum_value = 0;\n  let prod_value = 1;\n\n  for (let n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}",
  "9": "const rollingMax = (numbers) => {\n  let runningMax = null;\n  const result = [];\n\n  for (const n of numbers) {\n    if (runningMax === null) {\n      runningMax = n;\n    } else {\n      runningMax = Math.max(runningMax, n);\n    }\n\n    result.push(runningMax);\n  }\n\n  return result;\n};",
  "10": "const isPalindrome = (string) => {\n  return string === string.split(\"\").reverse().join(\"\");\n}\n\nconst makePalindrome = (string) => {\n  if (!string) {\n    return '';\n  }\n\n  let beginningOfSuffix = 0;\n\n  while (!isPalindrome(string.substring(beginningOfSuffix))) {\n    beginningOfSuffix++;\n  }\n\n  return string + string.substring(0, beginningOfSuffix).split(\"\").reverse().join(\"\");\n}",
  "11": "const stringXor = (a, b) => {\n  let result = \"\";\n  for (let i = 0; i < a.length; i++) {\n    result += (a[i] === b[i]) ? '0' : '1';\n  }\n  return result;\n};",
  "12": "const longest = (strings) => {\n  if (!strings) {\n    return null;\n  }\n\n  if (strings.length === 0) {\n      return null;\n  }\n\n  let maxlen = 0;\n  for (const s of strings) {\n    maxlen = Math.max(maxlen, s.length);\n  }\n\n  for (const s of strings) {\n    if (s.length === maxlen) {\n      return s;\n    }\n  }\n};",
  "13": "const greatest_common_divisor = (a, b) => {\n  while (b) {\n    [a, b] = [b, a % b];\n  }\n  return a;\n};",
  "14": "const allPrefixes = (string) => {\n  const result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.substring(0, i + 1));\n  }\n  return result;\n};",
  "15": "const stringSequence = (n) => {\n  let result = [];\n  for (let i = 0; i <= n; i++) {\n    result.push(i.toString());\n  }\n  return result.join(' ');\n};",
  "16": "const count_distinct_characters = (string) => {\n  return new Set(string.toLowerCase()).size;\n};",
  "17": "const parseMusic = (musicString) => {\n  const noteMap = {'o': 4, 'o|': 2, '.|': 1};\n  return musicString.split(' ').filter(x => x).map(x => noteMap[x]);\n}",
  "18": "const how_many_times = (string, substring) => {\n  let times = 0;\n\n  for (let i = 0; i <= string.length - substring.length; i++) {\n    if (string.substring(i, i + substring.length) === substring) {\n      times++;\n    }\n  }\n\n  return times;\n};",
  "19": "const sortNumbers = (numbers) => {\n  const valueMap = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n\n  if (!numbers) {\n    return '';\n  }\n\n  const numberArray = numbers.split(' ').filter(x => x); // Split and remove empty strings\n\n  numberArray.sort((a, b) => valueMap[a] - valueMap[b]);\n\n  return numberArray.join(' ');\n};",
  "20": "const findClosestElements = (numbers) => {\n  let closestPair = null;\n  let distance = null;\n\n  for (let idx = 0; idx < numbers.length; idx++) {\n    const elem = numbers[idx];\n    for (let idx2 = 0; idx2 < numbers.length; idx2++) {\n      if (idx !== idx2) {\n        const elem2 = numbers[idx2];\n        if (distance === null) {\n          distance = Math.abs(elem - elem2);\n          closestPair = [elem, elem2].sort((a, b) => a - b);\n        } else {\n          const newDistance = Math.abs(elem - elem2);\n          if (newDistance < distance) {\n            distance = newDistance;\n            closestPair = [elem, elem2].sort((a, b) => a - b);\n          }\n        }\n      }\n    }\n  }\n\n  return closestPair;\n};",
  "21": "const rescaleToUnit = (numbers) => {\n  const minNumber = Math.min(...numbers);\n  const maxNumber = Math.max(...numbers);\n  return numbers.map(x => (x - minNumber) / (maxNumber - minNumber));\n};",
  "22": "const filter_integers = (values) => {\n  return values.filter(x => typeof x === 'number' && Number.isInteger(x));\n};",
  "23": "const strlen = (string) => {\n  return string.length;\n};",
  "24": "const largestDivisor = (n) => {\n  for (let i = n - 1; i >= 1; i--) {\n    if (n % i === 0) {\n      return i;\n    }\n  }\n};",
  "25": "const factorize = (n) => {\n  const fact = [];\n  let i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i === 0) {\n      fact.push(i);\n      n /= i;\n    } else {\n      i++;\n    }\n  }\n\n  if (n > 1) {\n    fact.push(n);\n  }\n  return fact;\n};",
  "26": "const removeDuplicates = (numbers) => {\n  const counts = {};\n  for (const num of numbers) {\n    counts[num] = (counts[num] || 0) + 1;\n  }\n\n  const result = [];\n  for (const num of numbers) {\n    if (counts[num] <= 1) {\n      result.push(num);\n    }\n  }\n  return result;\n};",
  "27": "const flipCase = (string) => {\n  let result = \"\";\n  for (let i = 0; i < string.length; i++) {\n    const char = string[i];\n    if (char >= 'a' && char <= 'z') {\n      result += char.toUpperCase();\n    } else if (char >= 'A' && char <= 'Z') {\n      result += char.toLowerCase();\n    } else {\n      result += char;\n    }\n  }\n  return result;\n};",
  "28": "/**\n * @param {string[]} strings\n * @return {string}\n */\nconst concatenate = (strings) => {\n  return strings.join('');\n};",
  "29": "const filterByPrefix = (strings, prefix) => {\n  return strings.filter(str => str.startsWith(prefix));\n};",
  "30": "const getPositive = (l) => {\n\n  return l.filter(e => e > 0);\n}",
  "31": "const is_prime = (n) => {\n\n    if (n < 2) {\n        return false;\n    }\n    for (let k = 2; k < n; k++) {\n        if (n % k === 0) {\n            return false;\n        }\n    }\n    return true;\n}",
  "32": "const poly = (xs, x) => {\n  /**\n   * Evaluates polynomial with coefficients xs at point x.\n   * return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n   */\n  return xs.reduce((acc, coeff, i) => acc + coeff * Math.pow(x, i), 0);\n};\n\nconst findZero = (xs) => {\n  let begin = -1.0;\n  let end = 1.0;\n\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n\n  while (end - begin > 1e-10) {\n    const center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0) {\n      begin = center;\n    } else {\n      end = center;\n    }\n  }\n\n  return begin;\n};",
  "33": "const sortThird = (l) => {\n  l = [...l]; // Create a copy to avoid modifying the original array\n  const everyThird = [];\n  for (let i = 0; i < l.length; i += 3) {\n    everyThird.push(l[i]);\n  }\n\n  everyThird.sort((a, b) => a - b);\n\n  let everyThirdIndex = 0;\n  for (let i = 0; i < l.length; i += 3) {\n    l[i] = everyThird[everyThirdIndex];\n    everyThirdIndex++;\n  }\n\n  return l;\n};",
  "34": "const unique = (l) => {\n  return [...new Set(l)].sort((a, b) => a - b);\n};",
  "35": "const maxElement = (l) => {\n  let m = l[0];\n  for (let e of l) {\n    if (e > m) {\n      m = e;\n    }\n  }\n  return m;\n};",
  "36": "const fizz_buzz = (n) => {\n  let ns = [];\n  for (let i = 0; i < n; i++) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      ns.push(i);\n    }\n  }\n  let s = ns.map(String).join('');\n  let ans = 0;\n  for (let c of s) {\n    if (c === '7') {\n      ans++;\n    }\n  }\n  return ans;\n};",
  "37": "const sortEven = (l) => {\n  const evens = l.filter((_, i) => i % 2 === 0);\n  const odds = l.filter((_, i) => i % 2 !== 0);\n  evens.sort((a, b) => a - b);\n\n  const ans = [];\n  for (let i = 0; i < Math.min(evens.length, odds.length); i++) {\n    ans.push(evens[i], odds[i]);\n  }\n\n  if (evens.length > odds.length) {\n    ans.push(evens[evens.length - 1]);\n  }\n\n  return ans;\n};",
  "38": "const encodeCyclic = (s) => {\n  // split string to groups. Each of length 3.\n  const groups = Array.from({ length: Math.floor((s.length + 2) / 3) }, (_, i) =>\n    s.slice(3 * i, Math.min(3 * i + 3, s.length))\n  );\n  // cycle elements in each group. Unless group has fewer elements than 3.\n  const modifiedGroups = groups.map((group) =>\n    group.length === 3 ? group.slice(1) + group[0] : group\n  );\n  return modifiedGroups.join(\"\");\n};\n\nconst decodeCyclic = (s) => {\n  return encodeCyclic(encodeCyclic(s));\n};",
  "39": "const prime_fib = (n) => {\n\n  const is_prime = (p) => {\n    if (p < 2) {\n      return false;\n    }\n    for (let k = 2; k <= Math.min(Math.sqrt(p), p - 1); k++) {\n      if (p % k === 0) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  let f = [0, 1];\n  while (true) {\n    f.push(f[f.length - 1] + f[f.length - 2]);\n    if (is_prime(f[f.length - 1])) {\n      n -= 1;\n    }\n    if (n === 0) {\n      return f[f.length - 1];\n    }\n  }\n};",
  "40": "const triplesSumToZero = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      for (let k = j + 1; k < l.length; k++) {\n        if (l[i] + l[j] + l[k] === 0) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};",
  "41": "const carRaceCollision = (n) => {\n  return n**2;\n}",
  "42": "const incrList = (l) => {\n  return l.map(e => e + 1);\n}",
  "43": "const pairsSumToZero = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n};",
  "44": "const changeBase = (x, base) => {\n  let ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n};",
  "45": "const triangle_area = (a, h) => {\n  return a * h / 2.0;\n}",
  "46": "const fib4 = (n) => {\n  const results = [0, 0, 2, 0];\n  if (n < 4) {\n    return results[n];\n  }\n\n  for (let i = 4; i <= n; i++) {\n    results.push(results[results.length - 1] + results[results.length - 2] + results[results.length - 3] + results[results.length - 4]);\n    results.shift();\n  }\n\n  return results[results.length - 1];\n}",
  "47": "const median = (l) => {\n  const sortedL = [...l].sort((a, b) => a - b);\n  const len = sortedL.length;\n\n  if (len % 2 === 1) {\n    return sortedL[Math.floor(len / 2)];\n  } else {\n    return (sortedL[len / 2 - 1] + sortedL[len / 2]) / 2.0;\n  }\n};",
  "48": "const isPalindrome = (text) => {\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] !== text[text.length - 1 - i]) {\n      return false;\n    }\n  }\n  return true;\n};",
  "49": "const modp = (n, p) => {\n  let ret = 1;\n  for (let i = 0; i < n; i++) {\n    ret = (2 * ret) % p;\n  }\n  return ret;\n};",
  "50": "const encodeShift = (s) => {\n  return Array.from(s)\n    .map(ch => {\n      const charCode = ch.charCodeAt(0);\n      const shiftedCharCode = ((charCode - 'a'.charCodeAt(0) + 5) % 26) + 'a'.charCodeAt(0);\n      return String.fromCharCode(shiftedCharCode);\n    })\n    .join('');\n};\n\nconst decodeShift = (s) => {\n  return Array.from(s)\n    .map(ch => {\n      const charCode = ch.charCodeAt(0);\n      let shiftedCharCode = ((charCode - 'a'.charCodeAt(0) - 5) % 26);\n      if (shiftedCharCode < 0) {\n          shiftedCharCode += 26;\n      }\n      shiftedCharCode += 'a'.charCodeAt(0);\n      return String.fromCharCode(shiftedCharCode);\n    })\n    .join('');\n};",
  "51": "const removeVowels = (text) => {\n  return text.split(\"\").filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"].includes(s.toLowerCase())).join(\"\");\n}",
  "52": "const belowThreshold = (l, t) => {\n  for (const e of l) {\n    if (e >= t) {\n      return false;\n    }\n  }\n  return true;\n};",
  "53": "const add = (x, y) => {\n  return x + y;\n}",
  "54": "const sameChars = (s0, s1) => {\n  const set0 = new Set(s0);\n  const set1 = new Set(s1);\n\n  if (set0.size !== set1.size) {\n    return false;\n  }\n\n  for (const char of set0) {\n    if (!set1.has(char)) {\n      return false;\n    }\n  }\n\n  return true;\n};",
  "55": "const fib = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 1;\n  }\n  return fib(n - 1) + fib(n - 2);\n};",
  "56": "const correct_bracketing = (brackets) => {\n  let depth = 0;\n  for (const b of brackets) {\n    if (b === \"<\") {\n      depth++;\n    } else {\n      depth--;\n    }\n    if (depth < 0) {\n      return false;\n    }\n  }\n  return depth === 0;\n};",
  "57": "const monotonic = (l) => {\n  const sortedAsc = [...l].sort((a, b) => a - b);\n  const sortedDesc = [...l].sort((a, b) => b - a);\n\n  if (JSON.stringify(l) === JSON.stringify(sortedAsc) || JSON.stringify(l) === JSON.stringify(sortedDesc)) {\n    return true;\n  }\n  return false;\n};",
  "58": "const common = (l1, l2) => {\n  const ret = new Set();\n  for (const e1 of l1) {\n    for (const e2 of l2) {\n      if (e1 === e2) {\n        ret.add(e1);\n      }\n    }\n  }\n  return Array.from(ret).sort((a, b) => a - b);\n};",
  "59": "const largestPrimeFactor = (n) => {\n\n  const isPrime = (k) => {\n    if (k < 2) {\n      return false;\n    }\n    for (let i = 2; i <= Math.sqrt(k); i++) {\n      if (k % i === 0) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  let largest = 1;\n  for (let j = 2; j <= n; j++) {\n    if (n % j === 0 && isPrime(j)) {\n      largest = Math.max(largest, j);\n    }\n  }\n  return largest;\n};",
  "60": "const sumToN = (n) => {\n  let sum = 0;\n  for (let i = 0; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};",
  "61": "const correctBracketing = (brackets) => {\n  let depth = 0;\n  for (const b of brackets) {\n    if (b === \"(\") {\n      depth += 1;\n    } else {\n      depth -= 1;\n    }\n    if (depth < 0) {\n      return false;\n    }\n  }\n  return depth === 0;\n};",
  "62": "const derivative = (xs) => {\n  return xs.map((x, i) => i * x).slice(1);\n};",
  "63": "const fibfib = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n === 2) {\n    return 1;\n  }\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n};",
  "64": "const vowels_count = (s) => {\n  const vowels = \"aeiouAEIOU\";\n  let n_vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      n_vowels++;\n    }\n  }\n  if (s.length > 0 && (s[s.length - 1] === 'y' || s[s.length - 1] === 'Y')) {\n    n_vowels++;\n  }\n  return n_vowels;\n};",
  "65": "const circular_shift = (x, shift) => {\n  const s = String(x);\n  const len = s.length;\n\n  if (shift > len) {\n    return s.split(\"\").reverse().join(\"\");\n  } else {\n    return s.substring(len - shift) + s.substring(0, len - shift);\n  }\n};",
  "66": "const digitSum = (s) => {\n  if (s === \"\") return 0;\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === s[i].toUpperCase() && s[i] !== s[i].toLowerCase()) {\n      sum += s.charCodeAt(i);\n    }\n  }\n  return sum;\n};",
  "67": "const fruitDistribution = (s, n) => {\n  const lis = [];\n  for (const i of s.split(' ')) {\n    if (!isNaN(parseInt(i))) {\n      lis.push(parseInt(i));\n    }\n  }\n  return n - lis.reduce((sum, num) => sum + num, 0);\n};",
  "68": "const pluck = (arr) => {\n  if (arr.length === 0) {\n    return [];\n  }\n\n  const evens = arr.filter(x => x % 2 === 0);\n\n  if (evens.length === 0) {\n    return [];\n  }\n\n  const minEven = Math.min(...evens);\n  const index = arr.indexOf(minEven);\n\n  return [minEven, index];\n};",
  "69": "const search = (lst) => {\n  if (lst.length === 0) {\n    return -1;\n  }\n\n  const maxVal = Math.max(...lst);\n  const frq = new Array(maxVal + 1).fill(0);\n\n  for (const i of lst) {\n    frq[i]++;\n  }\n\n  let ans = -1;\n  for (let i = 1; i < frq.length; i++) {\n    if (frq[i] >= i) {\n      ans = i;\n    }\n  }\n\n  return ans;\n};",
  "70": "const strangeSortList = (lst) => {\n  const res = [];\n  let switch_ = true;\n\n  while (lst.length > 0) {\n    let val;\n    if (switch_) {\n      val = Math.min(...lst);\n    } else {\n      val = Math.max(...lst);\n    }\n\n    res.push(val);\n    lst.splice(lst.indexOf(val), 1);\n    switch_ = !switch_;\n  }\n\n  return res;\n};",
  "71": "const triangleArea = (a, b, c) => {\n  if (a + b <= c || a + c <= b || b + c <= a) {\n    return -1;\n  }\n  const s = (a + b + c) / 2;\n  let area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n  area = Math.round(area * 100) / 100;\n  return area;\n};",
  "72": "const willItFly = (q, w) => {\n  if (q.reduce((sum, num) => sum + num, 0) > w) {\n    return false;\n  }\n\n  let i = 0;\n  let j = q.length - 1;\n  while (i < j) {\n    if (q[i] !== q[j]) {\n      return false;\n    }\n    i++;\n    j--;\n  }\n  return true;\n};",
  "73": "const smallestChange = (arr) => {\n  let ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++) {\n    if (arr[i] !== arr[arr.length - i - 1]) {\n      ans += 1;\n    }\n  }\n  return ans;\n};",
  "74": "const totalMatch = (lst1, lst2) => {\n  let l1 = 0;\n  for (const st of lst1) {\n    l1 += st.length;\n  }\n\n  let l2 = 0;\n  for (const st of lst2) {\n    l2 += st.length;\n  }\n\n  if (l1 <= l2) {\n    return lst1;\n  } else {\n    return lst2;\n  }\n};",
  "75": "const isMultiplyPrime = (a) => {\n\n  const isPrime = (n) => {\n    if (n <= 1) return false;\n    for (let j = 2; j < n; j++) {\n      if (n % j == 0) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  for (let i = 2; i <= 100; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j <= 100; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k <= 100; k++) {\n        if (!isPrime(k)) continue;\n        if (i * j * k == a) return true;\n      }\n    }\n  }\n  return false;\n};",
  "76": "const isSimplePower = (x, n) => {\n  if (n === 1) {\n    return x === 1;\n  }\n\n  let power = 1;\n  while (power < x) {\n    power = power * n;\n  }\n\n  return power === x;\n};",
  "77": "const isCube = (a) => {\n  a = Math.abs(a);\n  const root = Math.round(a ** (1 / 3));\n  return root ** 3 === a;\n};",
  "78": "const hex_key = (num) => {\n  const primes = ['2', '3', '5', '7', 'B', 'D'];\n  let total = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (primes.includes(num[i])) {\n      total += 1;\n    }\n  }\n  return total;\n};",
  "79": "const decimalToBinary = (decimal) => {\n  return \"db\" + decimal.toString(2) + \"db\";\n};",
  "80": "const is_happy = (s) => {\n\n  if (s.length < 3) {\n    return false;\n  }\n\n  for (let i = 0; i < s.length - 2; i++) {\n    if (s[i] === s[i + 1] || s[i + 1] === s[i + 2] || s[i] === s[i + 2]) {\n      return false;\n    }\n  }\n  return true;\n};",
  "81": "const numericalLetterGrade = (grades) => {\n  const letterGrade = [];\n  for (const gpa of grades) {\n    if (gpa === 4.0) {\n      letterGrade.push(\"A+\");\n    } else if (gpa > 3.7) {\n      letterGrade.push(\"A\");\n    } else if (gpa > 3.3) {\n      letterGrade.push(\"A-\");\n    } else if (gpa > 3.0) {\n      letterGrade.push(\"B+\");\n    } else if (gpa > 2.7) {\n      letterGrade.push(\"B\");\n    } else if (gpa > 2.3) {\n      letterGrade.push(\"B-\");\n    } else if (gpa > 2.0) {\n      letterGrade.push(\"C+\");\n    } else if (gpa > 1.7) {\n      letterGrade.push(\"C\");\n    } else if (gpa > 1.3) {\n      letterGrade.push(\"C-\");\n    } else if (gpa > 1.0) {\n      letterGrade.push(\"D+\");\n    } else if (gpa > 0.7) {\n      letterGrade.push(\"D\");\n    } else if (gpa > 0.0) {\n      letterGrade.push(\"D-\");\n    } else {\n      letterGrade.push(\"E\");\n    }\n  }\n  return letterGrade;\n};",
  "82": "const primeLength = (string) => {\n  let l = string.length;\n  if (l === 0 || l === 1) {\n    return false;\n  }\n  for (let i = 2; i < l; i++) {\n    if (l % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};",
  "83": "const startsOneEnds = (n) => {\n  if (n === 1) {\n    return 1;\n  }\n  return 18 * (10 ** (n - 2));\n};",
  "84": "const solve = (N) => {\n  const sum = String(N).split('').reduce((acc, digit) => acc + parseInt(digit), 0);\n  return sum.toString(2);\n};",
  "85": "const add = (lst) => {\n  let sum = 0;\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};",
  "86": "const antiShuffle = (s) => {\n  return s.split(' ').map(word => word.split('').sort().join('')).join(' ');\n};",
  "87": "const get_row = (lst, x) => {\n  const coords = [];\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j] === x) {\n        coords.push([i, j]);\n      }\n    }\n  }\n\n  coords.sort((a, b) => {\n    if (a[0] !== b[0]) {\n      return a[0] - b[0];\n    } else {\n      return b[1] - a[1];\n    }\n  });\n\n  return coords;\n};",
  "88": "const sortArray = (array) => {\n  if (array.length === 0) {\n    return [];\n  } else {\n    const shouldReverse = (array[0] + array[array.length - 1]) % 2 === 0;\n    return [...array].sort((a, b) => shouldReverse ? b - a : a - b);\n  }\n};",
  "89": "const encrypt = (s) => {\n  const d = 'abcdefghijklmnopqrstuvwxyz';\n  let out = '';\n  for (let c of s) {\n    if (d.includes(c)) {\n      out += d[(d.indexOf(c) + 4) % 26];\n    } else {\n      out += c;\n    }\n  }\n  return out;\n};",
  "90": "const nextSmallest = (lst) => {\n  if (!lst || lst.length < 2) {\n    return null;\n  }\n\n  const uniqueSorted = [...new Set(lst)].sort((a, b) => a - b);\n\n  if (uniqueSorted.length < 2) {\n    return null;\n  }\n\n  return uniqueSorted[1];\n};",
  "91": "const isBored = (S) => {\n  const sentences = S.split(/[.?!]\\s*/);\n  let count = 0;\n  for (let i = 0; i < sentences.length; i++) {\n    if (sentences[i].substring(0, 2) === 'I ') {\n      count++;\n    }\n  }\n  return count;\n};",
  "92": "const anyInt = (x, y, z) => {\n  if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {\n    if ((x + y === z) || (x + z === y) || (y + z === x)) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n};",
  "93": "const encode = (message) => {\n  const vowels = \"aeiouAEIOU\";\n  const vowels_replace = {};\n  for (let i = 0; i < vowels.length; i++) {\n    vowels_replace[vowels[i]] = String.fromCharCode(vowels.charCodeAt(i) + 2);\n  }\n\n  message = message.split('').map(char => {\n    if (char >= 'a' && char <= 'z') {\n      return char.toUpperCase();\n    } else if (char >= 'A' && char <= 'Z') {\n      return char.toLowerCase();\n    } else {\n      return char;\n    }\n  }).join('');\n\n  let encodedMessage = '';\n  for (let i = 0; i < message.length; i++) {\n    if (vowels.includes(message[i])) {\n      encodedMessage += vowels_replace[message[i]];\n    } else {\n      encodedMessage += message[i];\n    }\n  }\n\n  return encodedMessage;\n}",
  "94": "const skjkasdkd = (lst) => {\n\n    const isPrime = (n) => {\n        for (let i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i === 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    let maxx = 0;\n    let i = 0;\n    while (i < lst.length) {\n        if (lst[i] > maxx && isPrime(lst[i])) {\n            maxx = lst[i];\n        }\n        i++;\n    }\n    let result = 0;\n    const maxxStr = String(maxx);\n    for (let j = 0; j < maxxStr.length; j++) {\n        result += parseInt(maxxStr[j]);\n    }\n    return result;\n}",
  "95": "const checkDictCase = (dict) => {\n  const keys = Object.keys(dict);\n\n  if (keys.length === 0) {\n    return false;\n  } else {\n    let state = \"start\";\n    for (const key of keys) {\n      if (typeof key !== 'string') {\n        state = \"mixed\";\n        break;\n      }\n\n      if (state === \"start\") {\n        if (key === key.toUpperCase()) {\n          state = \"upper\";\n        } else if (key === key.toLowerCase()) {\n          state = \"lower\";\n        } else {\n          state = \"mixed\"; \n          break;\n        }\n      } else if ((state === \"upper\" && key !== key.toUpperCase()) || (state === \"lower\" && key !== key.toLowerCase())) {\n        state = \"mixed\";\n        break;\n      }\n    }\n    return state === \"upper\" || state === \"lower\";\n  }\n};",
  "96": "const countUpTo = (n) => {\n  const primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};",
  "97": "const multiply = (a, b) => {\n  return Math.abs(a % 10) * Math.abs(b % 10);\n}",
  "98": "const count_upper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (\"AEIOU\".includes(s[i])) {\n      count++;\n    }\n  }\n  return count;\n};",
  "99": "const closestInteger = (value) => {\n  if (value.includes('.')) {\n    // remove trailing zeros\n    while (value.endsWith('0')) {\n      value = value.slice(0, -1);\n    }\n  }\n\n  const num = parseFloat(value);\n\n  if (value.endsWith('.5')) {\n    return num > 0 ? Math.ceil(num) : Math.floor(num);\n  } else if (value.length > 0) {\n    return Math.round(num);\n  } else {\n    return 0;\n  }\n};",
  "100": "const makeAPile = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(n + 2 * i);\n  }\n  return result;\n};",
  "101": "const wordsString = (s) => {\n  if (!s) {\n    return [];\n  }\n\n  let s_list = [];\n\n  for (const letter of s) {\n    if (letter === ',') {\n      s_list.push(' ');\n    } else {\n      s_list.push(letter);\n    }\n  }\n\n  s_list = s_list.join('');\n  return s_list.split(' ').filter(word => word !== \"\");\n};",
  "102": "const chooseNum = (x, y) => {\n  if (x > y) {\n    return -1;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x === y) {\n    return -1;\n  }\n  return y - 1;\n};",
  "103": "const roundedAvg = (n, m) => {\n  if (m < n) {\n    return -1;\n  }\n\n  let summation = 0;\n  for (let i = n; i <= m; i++) {\n    summation += i;\n  }\n\n  return (Math.round(summation / (m - n + 1))).toString(2);\n};",
  "104": "const uniqueDigits = (x) => {\n  const oddDigitElements = [];\n  for (const i of x) {\n    const strI = String(i);\n    let allOdd = true;\n    for (const c of strI) {\n      if (parseInt(c) % 2 === 0) {\n        allOdd = false;\n        break;\n      }\n    }\n    if (allOdd) {\n      oddDigitElements.push(i);\n    }\n  }\n  return oddDigitElements.sort((a, b) => a - b);\n};",
  "105": "const by_length = (arr) => {\n\n  const dic = {\n    1: \"One\",\n    2: \"Two\",\n    3: \"Three\",\n    4: \"Four\",\n    5: \"Five\",\n    6: \"Six\",\n    7: \"Seven\",\n    8: \"Eight\",\n    9: \"Nine\",\n  };\n  const sorted_arr = [...arr].sort((a, b) => b - a);\n  const new_arr = [];\n  for (let varr of sorted_arr) {\n    if (dic[varr] !== undefined) {\n      new_arr.push(dic[varr]);\n    }\n  }\n  return new_arr;\n};",
  "106": "const f = (n) => {\n\n    let ret = [];\n    for (let i = 1; i <= n; i++){\n        if (i%2 === 0){\n            let x = 1;\n            for (let j = 1; j <= i; j++) x *= j;\n            ret.push(x);\n        } else {\n            let x = 0;\n            for (let j = 1; j <= i; j++) x += j;\n            ret.push(x);\n        }\n    }\n    return ret;\n}",
  "107": "const evenOddPalindrome = (n) => {\n\n  const isPalindrome = (n) => {\n    const strN = String(n);\n    return strN === strN.split(\"\").reverse().join(\"\");\n  };\n\n  let evenPalindromeCount = 0;\n  let oddPalindromeCount = 0;\n\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1 && isPalindrome(i)) {\n      oddPalindromeCount += 1;\n    } else if (i % 2 === 0 && isPalindrome(i)) {\n      evenPalindromeCount += 1;\n    }\n  }\n  return [evenPalindromeCount, oddPalindromeCount];\n};",
  "108": "const countNums = (arr) => {\n\n  const digitsSum = (n) => {\n    let neg = 1;\n    if (n < 0) {\n      n = -1 * n;\n      neg = -1;\n    }\n    const nStr = String(n);\n    const nArr = nStr.split(\"\").map(Number);\n    nArr[0] = nArr[0] * neg;\n    return nArr.reduce((sum, digit) => sum + digit, 0);\n  };\n\n  return arr.map(digitsSum).filter(x => x > 0).length;\n};",
  "109": "const moveOneBall = (arr) => {\n\n  if (arr.length === 0) {\n    return true;\n  }\n\n  const sortedArray = [...arr].sort((a, b) => a - b);\n  let myArr = [];\n\n  const minValue = Math.min(...arr);\n  const minIndex = arr.indexOf(minValue);\n\n  myArr = arr.slice(minIndex).concat(arr.slice(0, minIndex));\n\n  for (let i = 0; i < arr.length; i++) {\n    if (myArr[i] !== sortedArray[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}",
  "110": "const exchange = (lst1, lst2) => {\n  let odd = 0;\n  let even = 0;\n\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 === 1) {\n      odd++;\n    }\n  }\n\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      even++;\n    }\n  }\n\n  if (even >= odd) {\n    return \"YES\";\n  }\n\n  return \"NO\";\n};",
  "111": "const histogram = (test) => {\n  const dict1 = {};\n  const list1 = test.split(\" \");\n  let t = 0;\n\n  for (const i of list1) {\n    if (list1.filter(x => x === i).length > t && i !== \"\") {\n      t = list1.filter(x => x === i).length;\n    }\n  }\n\n  if (t > 0) {\n    for (const i of list1) {\n      if (list1.filter(x => x === i).length === t) {\n        dict1[i] = t;\n      }\n    }\n  }\n\n  return dict1;\n};",
  "112": "const reverseDelete = (s, c) => {\n  let newS = \"\";\n  for (let char of s) {\n    if (!c.includes(char)) {\n      newS += char;\n    }\n  }\n  return [newS, newS === newS.split('').reverse().join('')];\n};",
  "113": "const odd_count = (lst) => {\n  const res = [];\n  for (const arr of lst) {\n    let n = 0;\n    for (const d of arr) {\n      if (parseInt(d) % 2 === 1) {\n        n++;\n      }\n    }\n    res.push(\"the number of odd elements \" + n + \"n the str\" + n + \"ng \" + n + \" of the \" + n + \"nput.\");\n  }\n  return res;\n};",
  "114": "const minSubArraySum = (nums) => {\n  let max_sum = 0;\n  let s = 0;\n  for (let num of nums) {\n    s += -num;\n    if (s < 0) {\n      s = 0;\n    }\n    max_sum = Math.max(s, max_sum);\n  }\n  if (max_sum === 0) {\n    max_sum = Math.max(...nums.map(i => -i));\n  }\n  const min_sum = -max_sum;\n  return min_sum;\n};",
  "115": "const maxFill = (grid, capacity) => {\n  return grid.reduce((sum, arr) => {\n    const rowSum = arr.reduce((acc, val) => acc + val, 0);\n    return sum + Math.ceil(rowSum / capacity);\n  }, 0);\n};",
  "116": "const sortArray = (arr) => {\n  return [...arr].sort((a, b) => {\n    const countBits = (num) => {\n      let count = 0;\n      num = Math.abs(num); // Handle negative numbers correctly\n      while (num > 0) {\n        count += (num & 1);\n        num >>= 1;\n      }\n      return count;\n    };\n\n    const bitsA = countBits(a);\n    const bitsB = countBits(b);\n\n    if (bitsA !== bitsB) {\n      return bitsA - bitsB;\n    } else {\n      return a - b; // Maintain original order for elements with same number of bits\n    }\n  });\n};",
  "117": "const selectWords = (s, n) => {\n  const result = [];\n  const words = s.split(\" \");\n\n  for (const word of words) {\n    let n_consonants = 0;\n    for (let i = 0; i < word.length; i++) {\n      if (![\"a\", \"e\", \"i\", \"o\", \"u\"].includes(word[i].toLowerCase())) {\n        n_consonants++;\n      }\n    }\n    if (n_consonants === n) {\n      result.push(word);\n    }\n  }\n  return result;\n};",
  "118": "const getClosestVowel = (word) => {\n  if (word.length < 3) {\n    return \"\";\n  }\n\n  const vowels = new Set([\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"O\", \"U\", \"I\"]);\n  for (let i = word.length - 2; i > 0; i--) {\n    if (vowels.has(word[i])) {\n      if (!vowels.has(word[i + 1]) && !vowels.has(word[i - 1])) {\n        return word[i];\n      }\n    }\n  }\n  return \"\";\n};",
  "119": "const matchParens = (lst) => {\n\n    const check = (s) => {\n        let val = 0;\n        for (let i = 0; i < s.length; i++) {\n            if (s[i] == '(') {\n                val = val + 1;\n            } else {\n                val = val - 1;\n            }\n            if (val < 0) {\n                return false;\n            }\n        }\n        return val == 0;\n    }\n\n    const S1 = lst[0] + lst[1];\n    const S2 = lst[1] + lst[0];\n    return check(S1) || check(S2) ? 'Yes' : 'No';\n}",
  "120": "const maximum = (arr, k) => {\n  if (k === 0) {\n    return [];\n  }\n  const sortedArr = [...arr].sort((a, b) => a - b);\n  const ans = sortedArr.slice(-k);\n  return ans;\n};",
  "121": "const solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 2 === 0 && lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};",
  "122": "const addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < k; i++) {\n    if (String(arr[i]).length <= 2) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};",
  "123": "const getOddCollatz = (n) => {\n  let oddCollatz = n % 2 === 0 ? [] : [n];\n\n  while (n > 1) {\n    if (n % 2 === 0) {\n      n = n / 2;\n    } else {\n      n = n * 3 + 1;\n    }\n\n    if (n % 2 === 1) {\n      oddCollatz.push(Math.trunc(n));\n    }\n  }\n\n  return [...new Set(oddCollatz)].sort((a, b) => a - b);\n};",
  "124": "const validDate = (date) => {\n  try {\n    date = date.trim();\n    const [month, day, year] = date.split('-');\n    const m = parseInt(month);\n    const d = parseInt(day);\n    const y = parseInt(year);\n\n    if (isNaN(m) || isNaN(d) || isNaN(y)) {\n      return false;\n    }\n\n    if (m < 1 || m > 12) {\n      return false;\n    }\n\n    if ([1, 3, 5, 7, 8, 10, 12].includes(m) && (d < 1 || d > 31)) {\n      return false;\n    }\n\n    if ([4, 6, 9, 11].includes(m) && (d < 1 || d > 30)) {\n      return false;\n    }\n\n    if (m === 2) {\n      if (d < 1 || d > 29) {\n        return false;\n      }\n    }\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n};",
  "125": "const split_words = (txt) => {\n  if (txt.includes(\" \")) {\n    return txt.split(\" \");\n  } else if (txt.includes(\",\")) {\n    return txt.replace(/,/g, \" \").split(\" \");\n  } else {\n    let count = 0;\n    for (let i = 0; i < txt.length; i++) {\n      const char = txt[i];\n      if (char >= 'a' && char <= 'z' && char.charCodeAt(0) % 2 === 0) {\n        count++;\n      }\n    }\n    return count;\n  }\n};",
  "126": "const isSorted = (lst) => {\n  const countDigit = {};\n  for (const i of lst) {\n    countDigit[i] = 0;\n  }\n  for (const i of lst) {\n    countDigit[i]++;\n  }\n  for (const i in countDigit) {\n    if (countDigit[i] > 2) {\n      return false;\n    }\n  }\n\n  if (lst.length <= 1) {\n    return true;\n  }\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i - 1] > lst[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};",
  "127": "const intersection = (interval1, interval2) => {\n\n  const isPrime = (num) => {\n      if (num === 1 || num === 0) {\n          return false;\n      }\n      if (num === 2) {\n          return true;\n      }\n      for (let i = 2; i < num; i++) {\n          if (num % i === 0) {\n              return false;\n          }\n      }\n      return true;\n  }\n\n  const l = Math.max(interval1[0], interval2[0]);\n  const r = Math.min(interval1[1], interval2[1]);\n  const length = r - l;\n  if (length > 0 && isPrime(length)) {\n      return \"YES\";\n  }\n  return \"NO\";\n}",
  "128": "const prodSigns = (arr) => {\n  if (!arr || arr.length === 0) {\n    return null;\n  }\n\n  if (arr.includes(0)) {\n    return 0;\n  }\n\n  const negatives = arr.filter(x => x < 0).length;\n  const sign = negatives % 2 === 0 ? 1 : -1;\n\n  const sumOfAbs = arr.reduce((acc, num) => acc + Math.abs(num), 0);\n\n  return sign * sumOfAbs;\n};",
  "129": "const minPath = (grid, k) => {\n  const n = grid.length;\n  let val = n * n + 1;\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] === 1) {\n        let temp = [];\n        if (i !== 0) {\n          temp.push(grid[i - 1][j]);\n        }\n\n        if (j !== 0) {\n          temp.push(grid[i][j - 1]);\n        }\n\n        if (i !== n - 1) {\n          temp.push(grid[i + 1][j]);\n        }\n\n        if (j !== n - 1) {\n          temp.push(grid[i][j + 1]);\n        }\n\n        val = Math.min(...temp);\n      }\n    }\n  }\n\n  const ans = [];\n  for (let i = 0; i < k; i++) {\n    if (i % 2 === 0) {\n      ans.push(1);\n    } else {\n      ans.push(val);\n    }\n  }\n  return ans;\n};",
  "130": "const tri = (n) => {\n  if (n === 0) {\n    return [1];\n  }\n\n  let myTri = [1, 3];\n\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 === 0) {\n      myTri.push(i / 2 + 1);\n    } else {\n      myTri.push(myTri[i - 1] + myTri[i - 2] + (i + 3) / 2);\n    }\n  }\n\n  return myTri;\n};",
  "131": "const digits = (n) => {\n  let product = 1;\n  let odd_count = 0;\n  const n_string = String(n);\n\n  for (let i = 0; i < n_string.length; i++) {\n    const int_digit = parseInt(n_string[i]);\n    if (int_digit % 2 === 1) {\n      product = product * int_digit;\n      odd_count += 1;\n    }\n  }\n\n  if (odd_count === 0) {\n    return 0;\n  } else {\n    return product;\n  }\n};",
  "132": "const isNested = (string) => {\n  const openingBracketIndex = [];\n  const closingBracketIndex = [];\n\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === '[') {\n      openingBracketIndex.push(i);\n    } else if (string[i] === ']') {\n      closingBracketIndex.push(i);\n    }\n  }\n\n  closingBracketIndex.reverse();\n\n  let cnt = 0;\n  let i = 0;\n  const l = closingBracketIndex.length;\n\n  for (const idx of openingBracketIndex) {\n    if (i < l && idx < closingBracketIndex[i]) {\n      cnt++;\n      i++;\n    }\n  }\n\n  return cnt >= 2;\n};",
  "133": "const sumSquares = (lst) => {\n  let squared = 0;\n  for (let i = 0; i < lst.length; i++) {\n    squared += Math.ceil(lst[i]) ** 2;\n  }\n  return squared;\n};",
  "134": "const checkIfLastCharIsALetter = (txt) => {\n  const check = txt.split(' ').pop();\n  if (check.length === 1) {\n    const charCode = check.toLowerCase().charCodeAt(0);\n    return charCode >= 97 && charCode <= 122;\n  }\n  return false;\n};",
  "135": "const can_arrange = (arr) => {\n\n    let ind=-1\n    let i=1\n    while (i<arr.length){\n      if (arr[i]<arr[i-1]){\n        ind=i\n      }\n      i+=1\n    }\n    return ind\n\n}",
  "136": "const largest_smallest_integers = (lst) => {\n  const smallest = lst.filter(x => x < 0);\n  const largest = lst.filter(x => x > 0);\n\n  const maxSmallest = smallest.length > 0 ? Math.max(...smallest) : null;\n  const minLargest = largest.length > 0 ? Math.min(...largest) : null;\n\n  return [maxSmallest, minLargest];\n};",
  "137": "const compare_one = (a, b) => {\n  let tempA = a;\n  let tempB = b;\n\n  if (typeof tempA === 'string') {\n    tempA = tempA.replace(',', '.');\n  }\n  if (typeof tempB === 'string') {\n    tempB = tempB.replace(',', '.');\n  }\n\n  if (parseFloat(tempA) === parseFloat(tempB)) {\n    return null;\n  }\n\n  return parseFloat(tempA) > parseFloat(tempB) ? a : b;\n};",
  "138": "const isEqualtoSumEven = (n) => {\n  return n % 2 === 0 && n >= 8;\n};",
  "139": "const special_factorial = (n) => {\n\n  let fact_i = 1;\n  let special_fact = 1;\n  for (let i = 1; i <= n; i++) {\n    fact_i *= i;\n    special_fact *= fact_i;\n  }\n  return special_fact;\n}",
  "140": "const fixSpaces = (text) => {\n  let newText = \"\";\n  let i = 0;\n  let start = 0;\n  let end = 0;\n\n  while (i < text.length) {\n    if (text[i] === \" \") {\n      end++;\n    } else {\n      if (end - start > 2) {\n        newText += \"-\" + text[i];\n      } else if (end - start > 0) {\n        newText += \"_\".repeat(end - start) + text[i];\n      } else {\n        newText += text[i];\n      }\n      start = i + 1;\n      end = i + 1;\n    }\n    i++;\n  }\n\n  if (end - start > 2) {\n    newText += \"-\";\n  } else if (end - start > 0) {\n    newText += \"_\".repeat(end - start);\n  }\n\n  return newText;\n};",
  "141": "const fileNameCheck = (fileName) => {\n  const suf = ['txt', 'exe', 'dll'];\n  const lst = fileName.split('.');\n\n  if (lst.length !== 2) {\n    return 'No';\n  }\n\n  if (!suf.includes(lst[1])) {\n    return 'No';\n  }\n\n  if (lst[0].length === 0) {\n    return 'No';\n  }\n\n  if (!/^[a-zA-Z]/.test(lst[0][0])) {\n    return 'No';\n  }\n\n  let t = 0;\n  for (const char of lst[0]) {\n    if (!isNaN(parseInt(char))) {\n      t++;\n    }\n  }\n\n  if (t > 3) {\n    return 'No';\n  }\n\n  return 'Yes';\n};",
  "142": "const sumSquares = (lst) => {\n  let result = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      result.push(lst[i] ** 2);\n    } else if (i % 4 === 0 && i % 3 !== 0) {\n      result.push(lst[i] ** 3);\n    } else {\n      result.push(lst[i]);\n    }\n  }\n  let sum = 0;\n  for (let i = 0; i < result.length; i++) {\n    sum += result[i];\n  }\n  return sum;\n};",
  "143": "const wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newLst = [];\n\n  for (const word of words) {\n    let flg = 0;\n    if (word.length === 1) {\n      flg = 1;\n    }\n    for (let i = 2; i < word.length; i++) {\n      if (word.length % i === 0) {\n        flg = 1;\n        break; // Optimization: no need to continue checking if divisible\n      }\n    }\n    if (flg === 0 || word.length === 2) {\n      newLst.push(word);\n    }\n  }\n  return newLst.join(\" \");\n};",
  "144": "const simplify = (x, n) => {\n  const [a, b] = x.split(\"/\");\n  const [c, d] = n.split(\"/\");\n  const numerator = parseInt(a) * parseInt(c);\n  const denom = parseInt(b) * parseInt(d);\n  if (Number.isInteger(numerator / denom)) {\n    return true;\n  }\n  return false;\n};",
  "145": "const orderByPoints = (nums) => {\n\n  const digitsSum = (n) => {\n    let neg = 1;\n    if (n < 0) {\n      n = -1 * n;\n      neg = -1;\n    }\n    const nStr = String(n);\n    const nArr = nStr.split(\"\").map(Number);\n    nArr[0] = nArr[0] * neg;\n    return nArr.reduce((sum, num) => sum + num, 0);\n  };\n\n  return nums.sort((a, b) => digitsSum(a) - digitsSum(b));\n};",
  "146": "const specialFilter = (nums) => {\n\n    let count = 0;\n    for (let num of nums) {\n        if (num > 10) {\n            const odd_digits = [1, 3, 5, 7, 9];\n            const number_as_string = String(num);\n            if (odd_digits.includes(parseInt(number_as_string[0])) && odd_digits.includes(parseInt(number_as_string[number_as_string.length - 1]))) {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}",
  "147": "const getMaxTriples = (n) => {\n  const A = Array.from({ length: n }, (_, i) => (i + 1) * (i + 1) - (i + 1) + 1);\n  let ans = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((A[i] + A[j] + A[k]) % 3 === 0) {\n          ans.push([A[i], A[j], A[k]]);\n        }\n      }\n    }\n  }\n  return ans.length;\n};",
  "148": "const bf = (planet1, planet2) => {\n  const planetNames = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n\n  if (!planetNames.includes(planet1) || !planetNames.includes(planet2) || planet1 === planet2) {\n    return [];\n  }\n\n  const planet1Index = planetNames.indexOf(planet1);\n  const planet2Index = planetNames.indexOf(planet2);\n\n  if (planet1Index < planet2Index) {\n    return planetNames.slice(planet1Index + 1, planet2Index);\n  } else {\n    return planetNames.slice(planet2Index + 1, planet1Index);\n  }\n};",
  "149": "const sortedListSum = (lst) => {\n  lst.sort();\n  let new_lst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      new_lst.push(lst[i]);\n    }\n  }\n  new_lst.sort((a, b) => a.length - b.length);\n  return new_lst;\n};",
  "150": "const xOrY = (n, x, y) => {\n  if (n === 1) {\n    return y;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return y;\n    }\n  }\n  return x;\n};",
  "151": "const doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] % 2 !== 0 && String(lst[i]).indexOf(\".\") === -1) {\n      sum += lst[i] ** 2;\n    }\n  }\n  return sum;\n};",
  "152": "const compare = (game, guess) => {\n  return game.map((x, i) => Math.abs(x - guess[i]));\n};",
  "153": "const Strongest_Extension = (class_name, extensions) => {\n  let strong = extensions[0];\n  let my_val = 0;\n  for (let i = 0; i < extensions[0].length; i++) {\n    if (extensions[0][i].match(/[a-zA-Z]/)) {\n      if (extensions[0][i] === extensions[0][i].toUpperCase()) {\n        my_val++;\n      } else {\n        my_val--;\n      }\n    }\n  }\n\n  for (let s of extensions) {\n    let val = 0;\n    for (let i = 0; i < s.length; i++) {\n      if (s[i].match(/[a-zA-Z]/)) {\n        if (s[i] === s[i].toUpperCase()) {\n          val++;\n        } else {\n          val--;\n        }\n      }\n    }\n\n    if (val > my_val) {\n      strong = s;\n      my_val = val;\n    }\n  }\n\n  let ans = class_name + \".\" + strong;\n  return ans;\n};",
  "154": "const cycpatternCheck = (a, b) => {\n  const l = b.length;\n  const pat = b + b;\n  for (let i = 0; i <= a.length - l; i++) {\n    for (let j = 0; j <= l; j++) {\n      if (a.substring(i, i + l) === pat.substring(j, j + l)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};",
  "155": "const even_odd_count = (num) => {\n  let even_count = 0;\n  let odd_count = 0;\n  const numStr = Math.abs(num).toString();\n\n  for (let i = 0; i < numStr.length; i++) {\n    const digit = parseInt(numStr[i]);\n    if (digit % 2 === 0) {\n      even_count++;\n    } else {\n      odd_count++;\n    }\n  }\n  return [even_count, odd_count];\n};",
  "156": "const intToMiniRoman = (number) => {\n  const num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n  const sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"];\n  let i = 12;\n  let res = '';\n\n  while (number) {\n    const div = Math.floor(number / num[i]);\n    number %= num[i];\n\n    while (div) {\n      res += sym[i];\n      div -= 1;\n    }\n    i -= 1;\n  }\n\n  return res.toLowerCase();\n};",
  "157": "const rightAngleTriangle = (a, b, c) => {\n  return a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b;\n}",
  "158": "const find_max = (words) => {\n  return words.sort((a, b) => {\n    const setA = new Set(a);\n    const setB = new Set(b);\n    const lenA = setA.size;\n    const lenB = setB.size;\n\n    if (lenA !== lenB) {\n      return lenA - lenB; // Sort in descending order of unique characters\n    } else {\n      return a.localeCompare(b); // If same number of unique characters, sort lexicographically\n    }\n  })[0];\n};",
  "159": "const eat = (number, need, remaining) => {\n  if (need <= remaining) {\n    return [number + need, remaining - need];\n  } else {\n    return [number + remaining, 0];\n  }\n};",
  "160": "const do_algebra = (operator, operand) => {\n  let expression = String(operand[0]);\n  for (let i = 0; i < operator.length; i++) {\n    expression += operator[i] + String(operand[i + 1]);\n  }\n  return eval(expression);\n};",
  "161": "const solve = (s) => {\n  let flg = 0;\n  let idx = 0;\n  const newStr = s.split('');\n  for (let i = 0; i < s.length; i++) {\n    if (/[a-zA-Z]/.test(s[i])) {\n      newStr[idx] = s[i] === s[i].toUpperCase() ? s[i].toLowerCase() : s[i].toUpperCase();\n      flg = 1;\n    }\n    idx++;\n  }\n  const newS = newStr.join('');\n  if (flg === 0) {\n    return newS.split('').reverse().join('');\n  }\n  return newS;\n};",
  "162": "const stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const crypto = require('crypto');\n  const md5Hash = crypto.createHash('md5').update(text, 'ascii').digest('hex');\n  return md5Hash;\n};",
  "163": "const generateIntegers = (a, b) => {\n  const lower = Math.max(2, Math.min(a, b));\n  const upper = Math.min(8, Math.max(a, b));\n\n  const result = [];\n  for (let i = lower; i <= upper; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};"
}