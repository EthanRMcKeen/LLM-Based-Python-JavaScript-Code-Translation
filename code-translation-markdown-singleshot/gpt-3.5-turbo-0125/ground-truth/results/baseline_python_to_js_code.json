{
  "0": "const hasCloseElements = (numbers, threshold) => {\n    for (let i = 0; i < numbers.length; i++) {\n        for (let j = 0; j < numbers.length; j++) {\n            if (i !== j) {\n                const distance = Math.abs(numbers[i] - numbers[j]);\n                if (distance < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n",
  "1": "const separateParenGroups = (parenString) => {\n    const result = [];\n    let currentString = [];\n    let currentDepth = 0;\n\n    for (let c of parenString) {\n        if (c === '(') {\n            currentDepth += 1;\n            currentString.push(c);\n        } else if (c === ')') {\n            currentDepth -= 1;\n            currentString.push(c);\n\n            if (currentDepth === 0) {\n                result.push(currentString.join(''));\n                currentString = [];\n            }\n        }\n    }\n\n    return result;\n};\n",
  "2": "const truncateNumber = (number) => {\n    return number % 1.0;\n}\n",
  "3": "const belowZero = (operations) => {\n\n  let balance = 0;\n\n  for (let op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n",
  "4": "const meanAbsoluteDeviation = (numbers) => {\n\n  const mean = numbers.reduce((acc, curr) => acc + curr, 0) / numbers.length;\n  return numbers.reduce((acc, curr) => acc + Math.abs(curr - mean), 0) / numbers.length;\n}\n",
  "5": "const intersperse = (numbers, delimiter) => {\n  if (!numbers.length) {\n    return [];\n  }\n\n  let result = [];\n\n  for (let i = 0; i < numbers.length - 1; i++) {\n    result.push(numbers[i]);\n    result.push(delimiter);\n  }\n\n  result.push(numbers[numbers.length - 1]);\n\n  return result;\n}\n",
  "6": "const parseNestedParens = (parenString) => {\n\n  const parseParenGroup = (s) => {\n    let depth = 0;\n    let maxDepth = 0;\n    for (let c of s) {\n      if (c === '(') {\n        depth += 1;\n        maxDepth = Math.max(depth, maxDepth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return maxDepth;\n  };\n\n  return parenString.split(' ').filter(x => x).map(x => parseParenGroup(x));\n}\n  ",
  "7": "const filterBySubstring = (strings, substring) => {\n    return strings.filter(x => x.includes(substring));\n}\n",
  "8": "const sumProduct = (numbers) => {\n  let sumValue = 0;\n  let prodValue = 1;\n\n  for (let n of numbers) {\n    sumValue += n;\n    prodValue *= n;\n  }\n\n  return [sumValue, prodValue];\n}\n",
  "9": "const rollingMax = (numbers) => {\n    let runningMax = null;\n    const result = [];\n\n    numbers.forEach(n => {\n        if (runningMax === null) {\n            runningMax = n;\n        } else {\n            runningMax = Math.max(runningMax, n);\n        }\n\n        result.push(runningMax);\n    });\n\n    return result;\n}\n",
  "10": "const isPalindrome = (string) => {\n    return string === string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n    if (!string) {\n        return '';\n    }\n\n    let beginningOfSuffix = 0;\n\n    while (!isPalindrome(string.substring(beginningOfSuffix))) {\n        beginningOfSuffix++;\n    }\n\n    return string + string.substring(0, beginningOfSuffix).split('').reverse().join('');\n}\n\n",
  "11": "const stringXor = (a, b) => {\n\n    const xor = (i, j) => {\n        if (i === j) {\n            return '0';\n        } else {\n            return '1';\n        }\n    }\n\n    return Array.from(a).map((value, index) => xor(value, b[index])).join('');\n}\n\n",
  "12": "const longest = (strings) => {\n  if (strings.length === 0) {\n    return null;\n  }\n\n  let maxLength = Math.max(...strings.map(x => x.length));\n  for (let s of strings) {\n    if (s.length === maxLength) {\n      return s;\n    }\n  }\n}\n\n",
  "13": "const greatestCommonDivisor = (a, b) => {\n    while (b) {\n        [a, b] = [b, a % b];\n    }\n    return a;\n}\n",
  "14": "const allPrefixes = (string) => {\n  const result = [];\n\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i + 1));\n  }\n  return result;\n}\n",
  "15": "const stringSequence = (n) => {\n    return Array.from({length: n + 1}, (_, i) => String(i)).join(' ');\n}\n",
  "16": "const countDistinctCharacters = (string) => {\n  return new Set(string.toLowerCase()).size;\n}\n\n",
  "17": "const parseMusic = (musicString) => {\n    const noteMap = { 'o': 4, 'o|': 2, '.|': 1 };\n    return musicString.split(' ')\n                       .map(x => noteMap[x])\n                       .filter(Boolean);\n}\n",
  "18": "const howManyTimes = (string, substring) => {\n  let times = 0;\n\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i + substring.length) === substring) {\n      times++;\n    }\n  }\n\n  return times;\n}\n",
  "19": "const sortNumbers = (numbers) => {\n  const valueMap = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n\n  return numbers.split(' ').filter(x => x).sort((a, b) => valueMap[a] - valueMap[b]).join(' ');\n};\n",
  "20": "const findClosestElements = (numbers) => {\n    let closestPair = null;\n    let distance = null;\n\n    for (let i = 0; i < numbers.length; i++) {\n        for (let j = 0; j < numbers.length; j++) {\n            if (i !== j) {\n                if (distance === null) {\n                    distance = Math.abs(numbers[i] - numbers[j]);\n                    closestPair = [numbers[i], numbers[j]].sort((a, b) => a - b);\n                } else {\n                    let newDistance = Math.abs(numbers[i] - numbers[j]);\n                    if (newDistance < distance) {\n                        distance = newDistance;\n                        closestPair = [numbers[i], numbers[j]].sort((a, b) => a - b);\n                    }\n                }\n            }\n        }\n    }\n\n    return closestPair;\n}\n\n",
  "21": "const rescaleToUnit = (numbers) => {\n    let minNumber = Math.min(...numbers);\n    let maxNumber = Math.max(...numbers);\n    return numbers.map(x => (x - minNumber) / (maxNumber - minNumber));\n}\n",
  "22": "const filterIntegers = (values) => {\n  return values.filter(x => typeof x === 'number');\n}\n",
  "23": "const stringLength = (string) => {\n    return string.length;\n}\n",
  "24": "const largestDivisor = (n) => {\n    for (let i = n - 1; i > 0; i--) {\n        if (n % i === 0) {\n            return i;\n        }\n    }\n}\n  ",
  "25": "const factorize = (n) => {\n    let fact = [];\n    let i = 2;\n    while (i <= Math.sqrt(n) + 1) {\n        if (n % i === 0) {\n            fact.push(i);\n            n /= i;\n        } else {\n            i++;\n        }\n    }\n    if (n > 1) {\n        fact.push(n);\n    }\n    return fact;\n}\n",
  "26": "const removeDuplicates = (numbers) => {\n  const counter = numbers.reduce((acc, curr) => {\n    acc[curr] = (acc[curr] || 0) + 1;\n    return acc;\n  }, {});\n  \n  return numbers.filter((num) => counter[num] <= 1);\n}\n",
  "27": "const flipCase = (string) => {\n  return string.split('').map(char => {\n    if (char === char.toUpperCase()) {\n      return char.toLowerCase();\n    } else if (char === char.toLowerCase()) {\n      return char.toUpperCase();\n    }\n    return char;\n  }).join('');\n};",
  "28": "const concatenate = (strings) => {\n  return strings.join('');\n}\n",
  "29": "const filterByPrefix = (strings, prefix) => {\n  return strings.filter(x => x.startsWith(prefix));\n}\n",
  "30": "const getPositive = (arr) => {\n  return arr.filter(e => e > 0);\n}\n",
  "31": "const isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  for (let k = 2; k < n; k++) {\n    if (n % k === 0) {\n      return false;\n    }\n  }\n  return true;\n}\n",
  "32": "const poly = (xs, x) => {\n    return xs.reduce((acc, coeff, i) => acc + coeff * Math.pow(x, i), 0);\n}\n\nconst findZero = (xs) => {\n    let begin = -1.0;\n    let end = 1.0;\n    while (poly(xs, begin) * poly(xs, end) > 0) {\n        begin *= 2.0;\n        end *= 2.0;\n    }\n    while (end - begin > 1e-10) {\n        let center = (begin + end) / 2.0;\n        if (poly(xs, center) * poly(xs, begin) > 0) {\n            begin = center;\n        } else {\n            end = center;\n        }\n    }\n    return begin;\n}\n  ",
  "33": "const sortThird = (l) => {\n    l = Array.from(l);\n    l.filter((_, i) => i % 3 === 0).sort().forEach((value, i) => l[i * 3] = value);\n    return l;\n}\n",
  "34": "const unique = (l) => {\n  return l.filter((item, index) => l.indexOf(item) === index).sort();\n}  ",
  "35": "const maxElement = (l) => {\n    let m = l[0];\n    for (let i = 0; i < l.length; i++) {\n        if (l[i] > m) {\n            m = l[i];\n        }\n    }\n    return m;\n}\n",
  "36": "const fizzBuzz = (n) => {\n    let ns = []\n    for (let i = 0; i < n; i++) {\n        if (i % 11 === 0 || i % 13 === 0) {\n            ns.push(i)\n        }\n    }\n    let s = ns.join('')\n    let ans = 0\n    for (let c of s) {\n        ans += (c === '7')\n    }\n    return ans\n}\n",
  "37": "const sortEven = (l) => {\n  let evens = l.filter((_, index) => index % 2 === 0);\n  let odds = l.filter((_, index) => index % 2 !== 0);\n  evens.sort((a, b) => a - b);\n  \n  let ans = [];\n  for (let i = 0; i < evens.length; i++) {\n    ans.push(evens[i]);\n    if (i < odds.length) {\n      ans.push(odds[i]);\n    }\n  }\n  \n  if (evens.length > odds.length) {\n    ans.push(evens[evens.length - 1]);\n  }\n  \n  return ans;\n}\n",
  "38": "const encodeCyclic = (s) => {\n    let groups = [];\n    for (let i = 0; i < (s.length + 2) / 3; i++) {\n        groups.push(s.slice(3 * i, Math.min(3 * i + 3, s.length)));\n    }\n    groups = groups.map(group => group.length === 3 ? group.slice(1) + group[0] : group);\n    return groups.join('');\n}\n\nconst decodeCyclic = (s) => {\n    return encodeCyclic(encodeCyclic(s));\n}\n\nconst check = (decodeCyclic) => {\n    const letters = 'abcdefghijklmnopqrstuvwxyz';\n    for (let i = 0; i < 100; i++) {\n        let str = '';\n        const len = Math.floor(Math.random() * 11) + 10;\n        for (let j = 0; j < len; j++) {\n            str += letters[Math.floor(Math.random() * letters.length)];\n        }\n        const encodedStr = encodeCyclic(str);\n        if (decodeCyclic(encodedStr) !== str) throw new Error();\n    }\n}\n\ncheck(decodeCyclic);\n\n",
  "39": "const primeFib = (n) => {\n  \n  const isPrime = (p) => {\n    if (p < 2) return false;\n    for (let k = 2; k < Math.min(Math.sqrt(p) + 1, p - 1); k++) {\n      if (p % k === 0) return false;\n    }\n    return true;\n  };\n  \n  let f = [0, 1];\n  while (true) {\n    f.push(f[f.length - 1] + f[f.length - 2]);\n    if (isPrime(f[f.length - 1])) {\n      n--;\n    }\n    if (n === 0) {\n      return f[f.length - 1];\n    }\n  }\n};\n",
  "40": "const triplesSumToZero = (l) => {\n    for (let i = 0; i < l.length; i++) {\n        for (let j = i + 1; j < l.length; j++) {\n            for (let k = j + 1; k < l.length; k++) {\n                if (l[i] + l[j] + l[k] === 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n",
  "41": "const carRaceCollision = (n) => {\n  return Math.pow(n, 2);\n}\n",
  "42": "const incrList = (l) => {\n  return l.map(e => e + 1);\n}\n",
  "43": "const pairsSumToZero = (l) => {\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n",
  "44": "const changeBase = (x, base) => {\n  let ret = \"\";\n  while (x > 0) {\n    ret = (x % base) + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n",
  "45": "const triangleArea = (a, h) => {\n    return (a * h) / 2.0;\n}\n",
  "46": "const fib4 = (n) => {\n  let results = [0, 0, 2, 0];\n  if (n < 4) {\n    return results[n];\n  }\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results[3] + results[2] + results[1] + results[0]);\n    results.shift();\n  }\n  return results[3];\n}\n",
  "47": "const median = (l) => {\n    l.sort((a, b) => a - b);\n    if (l.length % 2 === 1) {\n        return l[Math.floor(l.length / 2)];\n    } else {\n        return (l[l.length / 2 - 1] + l[l.length / 2]) / 2.0;\n    }\n}\n",
  "48": "const isPalindrome = (text) => {\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] !== text[text.length - 1 - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n",
  "49": "const modp = (n, p) => {\n    let ret = 1;\n    for (let i = 0; i < n; i++) {\n        ret = (2 * ret) % p;\n    }\n    return ret;\n}\n",
  "50": "const encodeShift = (s) => {\n    return s.split(\"\").map(ch => String.fromCharCode(((ch.charCodeAt() + 5 - 'a'.charCodeAt()) % 26) + 'a'.charCodeAt())).join(\"\");\n}\n\nconst decodeShift = (s) => {\n    return s.split(\"\").map(ch => String.fromCharCode(((ch.charCodeAt() - 5 - 'a'.charCodeAt() + 26) % 26) + 'a'.charCodeAt())).join(\"\");\n}\n",
  "51": "const removeVowels = (text) => {\n    return [...text].filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"].includes(s.toLowerCase())).join('');\n}\n",
  "52": "const belowThreshold = (l, t) => {\n    for (let e of l) {\n        if (e >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n",
  "53": "const add = (x, y) => {\n  return x + y;\n}\n\n",
  "54": "const sameChars = (s0, s1) => {\n    return new Set(s0) === new Set(s1);\n}\n",
  "55": "const fib = (n) => {\n    if (n === 0) {\n        return 0;\n    }\n    if (n === 1) {\n        return 1;\n    }\n    return fib(n - 1) + fib(n - 2);\n}\n\nconst check = (fib) => {\n    console.assert(fib(10) === 55);\n    console.assert(fib(1) === 1);\n    console.assert(fib(8) === 21);\n    console.assert(fib(11) === 89);\n    console.assert(fib(12) === 144);\n}\n\ncheck(fib);\n\n",
  "56": "const correctBracketing = (brackets) => {\n    let depth = 0;\n    for (let b of brackets) {\n        if (b === \"<\") {\n            depth++;\n        } else {\n            depth--;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth === 0;\n}\n",
  "57": "const monotonic = (arr) => {\n    return arr.every((val, idx, array) => idx === 0 || val >= array[idx - 1]) ||\n           arr.every((val, idx, array) => idx === 0 || val <= array[idx - 1]);\n}\n  ",
  "58": "const common = (l1, l2) => {\n    let ret = new Set();\n    for (let e1 of l1) {\n        for (let e2 of l2) {\n            if (e1 === e2) {\n                ret.add(e1);\n            }\n        }\n    }\n    return Array.from(ret).sort();\n}\n\nconst check = (common) => {\n    assertArraysEqual(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]), [1, 5, 653]);\n    assertArraysEqual(common([5, 3, 2, 8], [3, 2]), [2, 3]);\n    assertArraysEqual(common([4, 3, 2, 8], [3, 2, 4]), [2, 3, 4]);\n    assertArraysEqual(common([4, 3, 2, 8], []), []);\n}\n\ncheck(common);\n\n",
  "59": "const largestPrimeFactor = (n) => {\n\n  const isPrime = (k) => {\n    if (k < 2) {\n      return false;\n    }\n    for (let i = 2; i < k - 1; i++) {\n      if (k % i === 0) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  let largest = 1;\n  for (let j = 2; j < n + 1; j++) {\n    if (n % j === 0 && isPrime(j)) {\n      largest = Math.max(largest, j);\n    }\n  }\n  return largest;\n};\n  ",
  "60": "javascript\nfunction sumToN(n) {\n  return ((n * (n + 1)) / 2);\n}\n\nfunction checkSumToN(sumToN) {\n  assert(sumToN(1) === 1);\n  assert(sumToN(6) === 21);\n  assert(sumToN(11) === 66);\n  assert(sumToN(30) === 465);\n  assert(sumToN(100) === 5050);\n}\n\ncheckSumToN(sumToN);\n}\n",
  "61": "const correctBracketing = (brackets) => {\n    let depth = 0;\n    for (let b of brackets) {\n        if (b === \"(\") {\n            depth += 1;\n        } else {\n            depth -= 1;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n    return depth === 0;\n}\n",
  "62": "const derivative = (xs) => {\n    return xs.map((x, i) => x * i).slice(1);\n}\n",
  "63": "const fibfib = (n) => {\n    if (n === 0) {\n        return 0;\n    }\n    if (n === 1) {\n        return 0;\n    }\n    if (n === 2) {\n        return 1;\n    }\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n",
  "64": "const vowelsCount = (s) => {\n    const vowels = \"aeiouAEIOU\";\n    let nVowels = 0;\n    for (const c of s) {\n        if (vowels.includes(c)) {\n            nVowels++;\n        }\n    }\n    if (s.slice(-1) === 'y' || s.slice(-1) === 'Y') {\n        nVowels++;\n    }\n    return nVowels;\n}\n\nconst check = (vowelsCount) => {\n    // Check some simple cases\n    console.assert(vowelsCount(\"abcde\") === 2, \"Test 1\");\n    console.assert(vowelsCount(\"Alone\") === 3, \"Test 2\");\n    console.assert(vowelsCount(\"key\") === 2, \"Test 3\");\n    console.assert(vowelsCount(\"bye\") === 1, \"Test 4\");\n    console.assert(vowelsCount(\"keY\") === 2, \"Test 5\");\n    console.assert(vowelsCount(\"bYe\") === 1, \"Test 6\");\n    console.assert(vowelsCount(\"ACEDY\") === 3, \"Test 7\");\n}\n\ncheck(vowelsCount);\n",
  "65": "const circularShift = (x, shift) => {\n    const s = String(x);\n    if (shift > s.length) {\n        return s.split(\"\").reverse().join(\"\");\n    } else {\n        return s.slice(s.length - shift) + s.slice(0, s.length - shift);\n    }\n}\n",
  "66": "const digitSum = (s) => {\n  if (s === \"\") return 0;\n  \n  let sum = 0;\n  for (let char of s) {\n    sum += char.toUpperCase() === char ? char.charCodeAt() : 0;\n  }\n  \n  return sum;\n}\n",
  "67": "const fruitDistribution = (s, n) => {\n  const numbers = s.split(' ').map(str => parseInt(str)).filter(num => !isNaN(num));\n  return n - numbers.reduce((acc, curr) => acc + curr, 0);\n}\n",
  "68": "const pluck = (arr) => {\n    if (arr.length === 0) return [];\n    const evens = arr.filter(x => x % 2 === 0);\n    if (evens.length === 0) return [];\n    return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n",
  "69": "javascript\nfunction search(lst) {\n    let frq = Array(Math.max(...lst) + 1).fill(0);\n    lst.forEach(i => frq[i]++);\n\n    let ans = -1;\n    for (let i = 1; i < frq.length; i++) {\n        if (frq[i] >= i) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n",
  "70": "const strangeSortList = (lst) => {\n    let res = [];\n    let switchFlag = true;\n\n    while (lst.length) {\n        if (switchFlag) {\n            res.push(Math.min(...lst));\n        } else {\n            res.push(Math.max(...lst));\n        }\n        lst.splice(lst.indexOf(res[res.length - 1]), 1);\n        switchFlag = !switchFlag;\n    }\n\n    return res;\n}\n",
  "71": "const triangleArea = (a, b, c) => {\n\n  if (a + b <= c || a + c <= b || b + c <= a) {\n    return -1; \n  }\n  const s = (a + b + c) / 2;  \n  const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n  return Math.round(area * 100) / 100;\n}\n",
  "72": "const willItFly = (q, w) => {\n\n    if (q.reduce((acc, curr) => acc + curr, 0) > w) {\n        return false;\n    }\n\n    let i = 0;\n    let j = q.length - 1;\n    while (i < j) {\n        if (q[i] !== q[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    return true;\n}\n  ",
  "73": "const smallestChange = (arr) => {\n\n  let ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++) {\n      if (arr[i] !== arr[arr.length - i - 1]) {\n          ans += 1;\n      }\n  }\n  return ans;\n}\n",
  "74": "const totalMatch = (lst1, lst2) => {\n\n    let l1 = 0;\n    lst1.forEach((st) => {\n        l1 += st.length;\n    });\n\n    let l2 = 0;\n    lst2.forEach((st) => {\n        l2 += st.length;\n    });\n\n    if (l1 <= l2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n",
  "75": "const isMultiplyPrime = (a) => {\n\n    const isPrime = (n) => {\n        for (let j = 2; j < n; j++) {\n            if (n % j === 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    for (let i = 2; i <= 100; i++) {\n        if (!isPrime(i)) continue;\n        for (let j = 2; j <= 100; j++) {\n            if (!isPrime(j)) continue;\n            for (let k = 2; k <= 100; k++) {\n                if (!isPrime(k)) continue;\n                if (i * j * k === a) return true;\n            }\n        }\n    }\n    return false;\n}\n\n",
  "76": "const isSimplePower = (x, n) => {\n    if (n == 1) {\n        return x == 1;\n    }\n    let power = 1;\n    while (power < x) {\n        power = power * n;\n    }\n    return power == x;\n}\n",
  "77": "const isCube = (a) => {\n    a = Math.abs(a);\n    return Math.round(Math.pow(a, 1 / 3)) ** 3 === a;\n}\n\nconst check = (isCube) => {\n    // Check some simple cases\n    console.assert(isCube(1) === true, \"First test error: \" + isCube(1));\n    console.assert(isCube(2) === false, \"Second test error: \" + isCube(2));\n    console.assert(isCube(-1) === true, \"Third test error: \" + isCube(-1));\n    console.assert(isCube(64) === true, \"Fourth test error: \" + isCube(64));\n    console.assert(isCube(180) === false, \"Fifth test error: \" + isCube(180));\n    console.assert(isCube(1000) === true, \"Sixth test error: \" + isCube(1000));\n\n    // Check some edge cases that are easy to work out by hand.\n    console.assert(isCube(0) === true, \"1st edge test error: \" + isCube(0));\n    console.assert(isCube(1729) === false, \"2nd edge test error: \" + isCube(1728));\n}\n\ncheck(isCube);\n\n",
  "78": "const hexKey = (num) => {\n    let primes = ['2', '3', '5', '7', 'B', 'D'];\n    let total = 0;\n    \n    for (let i = 0; i < num.length; i++) {\n        if (primes.includes(num[i])) {\n            total += 1;\n        }\n    }\n    \n    return total;\n}\n",
  "79": "const decimalToBinary = (decimal) => {\n    return \"db\" + decimal.toString(2) + \"db\";\n}\n",
  "80": "const isHappy = (s) => {\n    if (s.length < 3) {\n        return false;\n    }\n\n    for (let i = 0; i < s.length - 2; i++) {\n        if (s[i] === s[i+1] || s[i+1] === s[i+2] || s[i] === s[i+2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n",
  "81": "const numericalLetterGrade = (grades) => {\n    const letterGrade = [];\n    for (let gpa of grades) {\n        if (gpa === 4.0) letterGrade.push(\"A+\");\n        else if (gpa > 3.7) letterGrade.push(\"A\");\n        else if (gpa > 3.3) letterGrade.push(\"A-\");\n        else if (gpa > 3.0) letterGrade.push(\"B+\");\n        else if (gpa > 2.7) letterGrade.push(\"B\");\n        else if (gpa > 2.3) letterGrade.push(\"B-\");\n        else if (gpa > 2.0) letterGrade.push(\"C+\");\n        else if (gpa > 1.7) letterGrade.push(\"C\");\n        else if (gpa > 1.3) letterGrade.push(\"C-\");\n        else if (gpa > 1.0) letterGrade.push(\"D+\");\n        else if (gpa > 0.7) letterGrade.push(\"D\");\n        else if (gpa > 0.0) letterGrade.push(\"D-\");\n        else letterGrade.push(\"E\");\n    }\n    return letterGrade;\n}\n  ",
  "82": "const primeLength = (string) => {\n\n  let len = string.length;\n  if (len === 0 || len === 1) {\n      return false;\n  }\n  for (let i = 2; i < len; i++) {\n      if (len % i === 0) {\n          return false;\n      }\n  }\n  return true;\n}\n\n",
  "83": "const startsOneEnds = (n) => {\n    if (n === 1) return 1;\n    return 18 * Math.pow(10, n - 2);\n}\n",
  "84": "const solve = (N) => {\n  return (parseInt(N).toString(2));\n}\n",
  "85": "const add = (lst) => {\n  return lst.filter((num, index) => index % 2 == 1 && num % 2 == 0).reduce((acc, val) => acc + val, 0);\n}\n",
  "86": "const antiShuffle = (s) => {\n  return s.split(' ').map(i => i.split('').sort().join('')).join(' ');\n}\n",
  "87": "const getRow = (lst, x) => {\n    let coords = [];\n    lst.forEach((row, i) => {\n        row.forEach((val, j) => {\n            if (val === x) {\n                coords.push([i, j]);\n            }\n        });\n    });\n\n    return coords.sort((a, b) => {\n        if (a[0] === b[0]) {\n            return a[1] - b[1];\n        } else {\n            return b[0] - a[0];\n        }\n    }).sort((a, b) => a[0] - b[0]);\n}\n  ",
  "88": "const sortArray = (array) => {\n  return array.length === 0 ? [] : array.sort((a, b) => (a + b) % 2 === 0 ? b - a : a - b);\n}\n",
  "89": "const encrypt = (s) => {\n    const d = 'abcdefghijklmnopqrstuvwxyz';\n    let out = '';\n    for (let i = 0; i < s.length; i++) {\n        const c = s[i];\n        if (d.includes(c)) {\n            out += d[(d.indexOf(c) + 2 * 2) % 26];\n        } else {\n            out += c;\n        }\n    }\n    return out;\n}\n",
  "90": "const nextSmallest = (lst) => {\n    lst = Array.from(new Set(lst)).sort();\n    return (lst.length < 2) ? null : lst[1];\n}\n",
  "91": "const isBored = (s) => {\n  const sentences = s.split(/[.?!]\\s*/);\n  return sentences.reduce((count, sentence) => (sentence.slice(0, 2) === 'I ' ? count + 1 : count), 0);\n}\n",
  "92": "const anyInt = (x, y, z) => {\n  if (Number.isInteger(x) && Number.isInteger(y) && Number.isInteger(z)) {\n    if (x + y === z || x + z === y || y + z === x) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n}\n",
  "93": "const encodeMessage = (message) => {\n    const vowels = \"aeiouAEIOU\";\n    const vowelsReplace = Object.fromEntries([...vowels].map(i => [i, String.fromCharCode(i.charCodeAt(0) + 2)]));\n    message = message.split('').map(char => {\n        if (vowels.includes(char)) {\n            return vowelsReplace[char];\n        } else if (vowels.includes(char.toLowerCase())) {\n            return vowelsReplace[char.toLowerCase()].toUpperCase();\n        }\n        return char;\n    }).join('');\n    return message;\n}\n",
  "94": "const skjkasdkd = (lst) => {\n\n  const isPrime = (n) => {\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n      if (n % i === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  let maxx = 0;\n  let i = 0;\n  while (i < lst.length) {\n    if (lst[i] > maxx && isPrime(lst[i])) {\n      maxx = lst[i];\n    }\n    i++;\n  }\n\n  const result = String(maxx).split('').reduce((acc, digit) => acc + parseInt(digit), 0);\n  return result;\n}\n\n",
  "95": "const checkDictCase = (dict) => {\n    if (Object.keys(dict).length === 0) {\n        return false;\n    } else {\n        let state = \"start\";\n        for (let key in dict) {\n            if (typeof key !== \"string\") {\n                state = \"mixed\";\n                break;\n            }\n            if (state === \"start\") {\n                if (key.toUpperCase() === key) {\n                    state = \"upper\";\n                } else if (key.toLowerCase() === key) {\n                    state = \"lower\";\n                } else {\n                    break;\n                }\n            } else if ((state === \"upper\" && key.toUpperCase() !== key) || (state === \"lower\" && key.toLowerCase() !== key)) {\n                state = \"mixed\";\n                break;\n            } else {\n                break;\n            }\n        }\n        return state === \"upper\" || state === \"lower\";\n    }\n}\n\n  ",
  "96": "const countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i < n; i++) {\n    let isPrime = true;\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      primes.push(i);\n    }\n  }\n  return primes;\n}\n",
  "97": "const multiply = (a, b) => {\n    return Math.abs(a % 10) * Math.abs(b % 10);\n}\n",
  "98": "const countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 2) {\n    if (\"AEIOU\".includes(s[i])) {\n      count += 1;\n    }\n  }\n  return count;\n}\n",
  "99": "const closestInteger = (value) => {\n    if (value.includes('.')) {\n        while (value[value.length - 1] === '0') {\n            value = value.slice(0, -1);\n        }\n    }\n\n    let num = parseFloat(value);\n    let res;\n    if (value.slice(-2) === '.5') {\n        res = num > 0 ? Math.ceil(num) : Math.floor(num);\n    } else {\n        res = Math.round(num);\n    }\n\n    return res;\n}\n",
  "100": "const makeAPile = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(n + 2 * i);\n  }\n  return result;\n}\n\nconst check = (makeAPile) => {\n  assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]), \"Test 3\");\n  assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]), \"Test 4\");\n  assert(JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13]));\n  assert(JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16]));\n  assert(JSON.stringify(makeAPile(8)) === JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22]));\n\n  assert(true, \"This prints if this assert fails 2 (also good for debugging!)\");\n}\n\ncheck(makeAPile);\n\n",
  "101": "const wordsString = (s) => {\n\n  if (!s) {\n    return [];\n  }\n\n  const sList = [];\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === ',') {\n      sList.push(' ');\n    } else {\n      sList.push(s[i]);\n    }\n  }\n\n  const stringWithSpaces = sList.join('');\n  return stringWithSpaces.split(' ');\n\n}",
  "102": "const chooseNum = (x, y) => {\n\n  if (x > y) {\n    return -1;\n  }\n  if (y % 2 === 0) {\n    return y;\n  }\n  if (x === y) {\n    return -1;\n  }\n  return y - 1;\n}\n",
  "103": "const roundedAvg = (n, m) => {\n\n    if (m < n) {\n        return -1;\n    }\n\n    let summation = 0;\n    for (let i = n; i <= m; i++) {\n        summation += i;\n    }\n\n    return (summation / (m - n + 1)).toString(2);\n}\n",
  "104": "const uniqueDigits = (x) => {\n  const oddDigitElements = [];\n  for (let i of x) {\n    if (Array.from(String(i)).every(c => parseInt(c) % 2 === 1)) {\n      oddDigitElements.push(i);\n    }\n  }\n  return oddDigitElements.sort((a, b) => a - b);\n}\n",
  "105": "const byLength = (arr) => {\n\n  const dic = {\n    1: \"One\",\n    2: \"Two\",\n    3: \"Three\",\n    4: \"Four\",\n    5: \"Five\",\n    6: \"Six\",\n    7: \"Seven\",\n    8: \"Eight\",\n    9: \"Nine\",\n  };\n\n  const sortedArr = arr.sort((a, b) => b - a);\n  const newArr = [];\n  for (let val of sortedArr) {\n    try {\n      newArr.push(dic[val]);\n    } catch (error) {\n      // pass\n    }\n  }\n  return newArr;\n};\n\n",
  "106": "const f = (n) => {\n    const ret = [];\n    for (let i = 1; i <= n; i++) {\n        let x = 0;\n        if (i % 2 === 0) {\n            x = 1;\n            for (let j = 1; j <= i; j++) {\n                x *= j;\n            }\n        } else {\n            for (let j = 1; j <= i; j++) {\n                x += j;\n            }\n        }\n        ret.push(x);\n    }\n    return ret;\n}\n",
  "107": "const evenOddPalindrome = (n) => {\n\n  const isPalindrome = (num) => {\n    return num.toString() === num.toString().split('').reverse().join('');\n  }\n\n  let evenPalindromeCount = 0;\n  let oddPalindromeCount = 0;\n\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1 && isPalindrome(i)) {\n      oddPalindromeCount++;\n    } else if (i % 2 === 0 && isPalindrome(i)) {\n      evenPalindromeCount++;\n   }\n }\n  return [evenPalindromeCount, oddPalindromeCount];\n}\n\n",
  "108": "const countNums = (arr) => {\n\n  const digitsSum = (n) => {\n    let neg = 1;\n    if (n < 0) {\n      n = -1 * n;\n      neg = -1;\n    }\n    n = Array.from(String(n), Number);\n    n[0] = n[0] * neg;\n    return n.reduce((a, b) => a + b, 0);\n  }\n\n  return [...arr.filter(x => x > 0)].map(i => digitsSum(i)).length;\n}\n",
  "109": "const moveOneBall = (arr) => {\n  if (arr.length === 0) {\n    return true;\n  }\n  \n  const sortedArray = [...arr].sort((a, b) => a - b);\n  const minIndex = arr.indexOf(Math.min(...arr));\n  const myArr = arr.slice(minIndex).concat(arr.slice(0, minIndex));\n\n  for (let i = 0; i < arr.length; i++) {\n    if (myArr[i] !== sortedArray[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n",
  "110": "const exchange = (lst1, lst2) => {\n  let odd = 0;\n  let even = 0;\n  \n  lst1.forEach(i => {\n    if (i % 2 === 1) {\n      odd++;\n    }\n  });\n\n  lst2.forEach(i => {\n    if (i % 2 === 0) {\n      even++;\n    }\n  });\n\n  if (even >= odd) {\n    return \"YES\";\n  }\n  return \"NO\";\n}\n",
  "111": "const histogram = (test) => {\n    const dict1 = {};\n    const list1 = test.split(\" \");\n    let t = 0;\n\n    for (let i of list1) {\n        if (list1.filter(x => x === i).length > t && i !== '') {\n            t = list1.filter(x => x === i).length;\n        }\n    }\n\n    if (t > 0) {\n        for (let i of list1) {\n            if (list1.filter(x => x === i).length === t) {\n                dict1[i] = t;\n            }\n        }\n    }\n\n    return dict1;\n}\n\n",
  "112": "const reverseDelete = (s, c) => {\n  s = s.split('').filter(char => !c.includes(char)).join('');\n  return [s, s === s.split('').reverse().join('')];\n}\n",
  "113": "const oddCount = (lst) => {\n\n    let res = [];\n    for (let arr of lst) {\n        let n = 0;\n        for (let d of arr) {\n            if (parseInt(d) % 2 === 1) {\n                n++;\n            }\n        }\n        res.push(\"the number of odd elements \" + n + \"n the str\"+ n +\"ng \"+ n +\" of the \"+ n +\"nput.\");\n    }\n    return res;\n}\n",
  "114": "const minSubArraySum = (nums) => {\n  let maxSum = 0;\n  let s = 0;\n  nums.forEach(num => {\n    s += -num;\n    if (s < 0) {\n      s = 0;\n    }\n    maxSum = Math.max(s, maxSum);\n  });\n  if (maxSum === 0) {\n    maxSum = Math.max(...nums.map(i => -i));\n  }\n  const minSum = -maxSum;\n  return minSum;\n}\n",
  "115": "const maxFill = (grid, capacity) => {\n  let fillCount = 0;\n  for (let row of grid) {\n    let sumRow = row.reduce((acc, val) => acc + val, 0);\n    fillCount += Math.ceil(sumRow / capacity);\n  }\n  return fillCount;\n}\n",
  "116": "const sortArray = (arr) => {\n  return arr.sort((a, b) => {\n    const countBits = (num) => {\n      return num.toString(2).split('1').length - 1;\n    };\n    return countBits(a) - countBits(b) || a - b;\n  });\n};\n",
  "117": "const selectWords = (s, n) => {\n    let result = [];\n    const vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    \n    s.split(\" \").forEach(word => {\n        let nConsonants = 0;\n        for (let i = 0; i < word.length; i++) {\n            if (!vowels.includes(word[i].toLowerCase())) {\n                nConsonants += 1;\n            }\n        }\n        if (nConsonants === n) {\n            result.push(word);\n        }\n    });\n\n    return result;\n}\n\nconst check = (selectWords) => {\n    assert(JSON.stringify(selectWords(\"Mary had a little lamb\", 4)), JSON.stringify([\"little\"]), \"First test error: \" + JSON.stringify(selectWords(\"Mary had a little lamb\", 4)));\n    assert(JSON.stringify(selectWords(\"Mary had a little lamb\", 3)), JSON.stringify([\"Mary\", \"lamb\"]), \"Second test error: \" + JSON.stringify(selectWords(\"Mary had a little lamb\", 3)));\n    assert(JSON.stringify(selectWords(\"simple white space\", 2)), JSON.stringify([]), \"Third test error: \" + JSON.stringify(selectWords(\"simple white space\", 2)));\n    assert(JSON.stringify(selectWords(\"Hello world\", 4)), JSON.stringify([\"world\"]), \"Fourth test error: \" + JSON.stringify(selectWords(\"Hello world\", 4));\n    assert(JSON.stringify(selectWords(\"Uncle sam\", 3)), JSON.stringify([\"Uncle\"]), \"Fifth test error: \" + JSON.stringify(selectWords(\"Uncle sam\", 3)));\n\n    assert(JSON.stringify(selectWords(\"\", 4)), JSON.stringify([]), \"1st edge test error: \" + JSON.stringify(selectWords(\"\", 4));\n    assert(JSON.stringify(selectWords(\"a b c d e f\", 1)), JSON.stringify([\"b\", \"c\", \"d\", \"f\"]), \"2nd edge test error: \" + JSON.stringify(selectWords(\"a b c d e f\", 1));\n}\n\ncheck(selectWords);\n\n",
  "118": "const getClosestVowel = (word) => {\n    if (word.length < 3) {\n        return \"\";\n    }\n\n    const vowels = new Set([\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I']);\n    for (let i = word.length - 3; i > 0; i--) {\n        if (vowels.has(word[i])) {\n            if (!vowels.has(word[i + 1]) && !vowels.has(word[i - 1])) {\n                return word[i];\n            }\n        }\n    }\n    return \"\";\n}\n\n",
  "119": "const matchParens = (lst) => {\n\n    const check = (s) => {\n        let val = 0;\n        for (let i of s) {\n            if (i === '(') { val++; }\n            else { val--; }\n            if (val < 0) { return false; }\n        }\n        return (val === 0) ? true : false;\n    }\n\n    const S1 = lst[0] + lst[1];\n    const S2 = lst[1] + lst[0];\n    return (check(S1) || check(S2)) ? 'Yes' : 'No';\n}\n\n",
  "120": "const maximum = (arr, k) => {\n    if (k === 0) {\n        return [];\n    }\n    arr.sort((a, b) => a - b);\n    const ans = arr.slice(-k);\n    return ans;\n}\n",
  "121": "const solution = (lst) => {\n  return lst.reduce((acc, curr, idx) => idx % 2 === 0 && curr % 2 === 1 ? acc + curr : acc, 0);\n}\n  ",
  "122": "const addElements = (arr, k) => {\n  return arr.slice(0, k).reduce((sum, elem) => (elem.toString().length <= 2) ? sum + elem : sum, 0);\n}\n",
  "123": "const getOddCollatz = (n) => {\n    let oddCollatz = n % 2 === 0 ? [] : [n];\n    while (n > 1) {\n        if (n % 2 === 0) {\n            n = n / 2;\n        } else {\n            n = n * 3 + 1;\n        }\n        if (n % 2 === 1) {\n            oddCollatz.push(Math.floor(n));\n        }\n    }\n    return oddCollatz.sort((a, b) => a - b);\n}\n",
  "124": "const validDate = (date) => {\n\n    try {\n        date = date.trim();\n        const [month, day, year] = date.split('-').map(Number);\n        if (month < 1 || month > 12) {\n            return false;\n        }\n        if (([1,3,5,7,8,10,12].includes(month) && (day < 1 || day > 31)) ||\n            ([4,6,9,11].includes(month) && (day < 1 || day > 30)) ||\n            (month === 2 && (day < 1 || day > 29))) {\n            return false;\n        }\n    } catch(error) {\n        return false;\n    }\n\n    return true;\n}\n\n",
  "125": "const splitWords = (txt) => {\n    if (txt.includes(\" \")) {\n        return txt.split(\" \");\n    } else if (txt.includes(\",\")) {\n        return txt.replace(/,/g, \" \").split(\" \");\n    } else {\n        return txt.split('').filter(i => i.toLowerCase() === i && i.charCodeAt(0) % 2 === 0).length;\n    }\n}\n",
  "126": "const isSorted = (lst) => {\n    let countDigit = {};\n    lst.forEach(i => {\n        countDigit[i] = (countDigit[i] || 0) + 1;\n    });\n\n    if (Object.values(countDigit).some(val => val > 2)) {\n        return false;\n    }\n\n    for (let i = 1; i < lst.length; i++) {\n        if (lst[i - 1] > lst[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n",
  "127": "const intersection = (interval1, interval2) => {\n\n  const isPrime = (num) => {\n    if (num == 1 || num == 0) {\n      return false\n    }\n    if (num == 2) {\n      return true\n    }\n    for (let i = 2; i < num; i++) {\n      if (num % i == 0) {\n        return false\n      }\n    }\n    return true\n  }\n\n  let l = Math.max(interval1[0], interval2[0])\n  let r = Math.min(interval1[1], interval2[1])\n  let length = r - l\n  if (length > 0 && isPrime(length)) {\n    return \"YES\"\n  }\n  return \"NO\"\n}\n",
  "128": "const prodSigns = (arr) => {\n    if (!arr.length) return null;\n    const prod = arr.includes(0) ? 0 : Math.pow(-1, arr.filter(x => x < 0).length); // calculates the product based on negative numbers\n    return prod * arr.reduce((acc, curr) => acc + Math.abs(curr), 0); // returns the product multiplied by the sum of absolute values\n}\n",
  "129": "const minPath = (grid, k) => {\n\n    let n = grid.length;\n    let val = n * n + 1;\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === 1) {\n                let temp = [];\n\n                if (i !== 0) {\n                    temp.push(grid[i - 1][j]);\n                }\n                if (j !== 0) {\n                    temp.push(grid[i][j - 1]);\n                }\n                if (i !== n - 1) {\n                    temp.push(grid[i + 1][j]);\n                }\n                if (j !== n - 1) {\n                    temp.push(grid[i][j + 1]);\n                }\n\n                val = Math.min(...temp);\n            }\n        }\n    }\n\n    let ans = [];\n    for (let i = 0; i < k; i++) {\n        if (i % 2 === 0) {\n            ans.push(1);\n        } else {\n            ans.push(val);\n        }\n    }\n    return ans;\n}\n\n",
  "130": "const tri = (n) => {\n    if (n === 0) {\n        return [1];\n    }\n\n    let myTri = [1, 3];\n    for (let i = 2; i <= n; i++) {\n        if (i % 2 === 0) {\n            myTri.push(i / 2 + 1);\n        } else {\n            myTri.push(myTri[i - 1] + myTri[i - 2] + (i + 3) / 2);\n        }\n    }\n\n    return myTri;\n}\n",
  "131": "const digits = (n) => {\n\n  let product = 1\n  let oddCount = 0\n  for (let digit of n.toString()) {\n    const intDigit = parseInt(digit)\n    if (intDigit % 2 === 1) {\n      product *= intDigit\n      oddCount++\n    }\n  }\n\n  if (oddCount === 0) {\n    return 0\n  } else {\n    return product\n  }\n}",
  "132": "const isNested = (string) => {\n    let openingBracketIndex = [];\n    let closingBracketIndex = [];\n    \n    for (let i = 0; i < string.length; i++) {\n        if (string[i] === '[') {\n            openingBracketIndex.push(i);\n        } else {\n            closingBracketIndex.push(i);\n        }\n    }\n    closingBracketIndex.reverse();\n    \n    let count = 0;\n    let index = 0;\n    const length = closingBracketIndex.length;\n    \n    for (let idx of openingBracketIndex) {\n        if (index < length && idx < closingBracketIndex[index]) {\n            count++;\n            index++;\n        }\n    }\n    \n    return count >= 2;\n}\n\njavascript\nconst checkIsNested = (isNested) => {\n    // Check some simple cases\n    console.assert(isNested('[[]]') === true, \"This prints if this assert fails 1 (good for debugging!)\");\n    console.assert(isNested('[]]]]]]][[[[[]') === false);\n    console.assert(isNested('[][]') === false);\n    console.assert(isNested('[]') === false);\n    console.assert(isNested('[[[[]]]]') === true);\n    console.assert(isNested('[]]]]]]]]]]') === false);\n    console.assert(isNested('[][][[]]') === true);\n    console.assert(isNested('[[]') === false);\n    console.assert(isNested('[]]') === false);\n    console.assert(isNested('[[]][[') === true);\n    console.assert(isNested('[[][]]') === true);\n\n    // Check some edge cases that are easy to work out by hand.\n    console.assert(isNested('') === false, \"This prints if this assert fails 2 (also good for debugging!)\");\n    console.assert(isNested('[[[[[[[[') === false);\n    console.assert(isNested(']]]]]]]]') === false);\n}\n\ncheckIsNested(isNested);\n",
  "133": "const sumSquares = (lst) => {\n    let squared = 0;\n    for (let i = 0; i < lst.length; i++) {\n        squared += Math.ceil(lst[i]) ** 2;\n    }\n    return squared;\n}\n",
  "134": "const checkIfLastCharIsALetter = (txt) => {\n    const check = txt.split(' ').pop();\n    return check.length === 1 && check.toLowerCase().charCodeAt(0) >= 97 && check.toLowerCase().charCodeAt(0) <= 122;\n}\n",
  "135": "const canArrange = (arr) => {\n\n  let ind = -1\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < arr[i - 1]) {\n      ind = i\n    }\n  }\n  return ind\n\n}\n",
  "136": "const largestSmallestIntegers = (lst) => {\n\n  const smallest = lst.filter(x => x < 0);\n  const largest = lst.filter(x => x > 0);\n  return [(smallest.length > 0 ? Math.max(...smallest) : null), (largest.length > 0 ? Math.min(...largest) : null)];\n\n}\n",
  "137": "const compareOne = (a, b) => {\n    let tempA = a, tempB = b;\n    if (typeof tempA === 'string') tempA = tempA.replace(',', '.');\n    if (typeof tempB === 'string') tempB = tempB.replace(',', '.');\n    if (parseFloat(tempA) === parseFloat(tempB)) return null;\n    return parseFloat(tempA) > parseFloat(tempB) ? a : b;\n}\n  ",
  "138": "const isEqualToSumEven = (n) => {\n  return n % 2 === 0 && n >= 8;\n}\n",
  "139": "const specialFactorial = (n) => {\n    let factI = 1;\n    let specialFact = 1;\n    for (let i = 1; i <= n; i++) {\n        factI *= i;\n        specialFact *= factI;\n    }\n    return specialFact;\n}\n",
  "140": "const fixSpaces = (text) => {\n    let new_text = \"\";\n    let i = 0;\n    let start = 0, end = 0;\n    while (i < text.length) {\n        if (text[i] === \" \") {\n            end += 1;\n        } else {\n            if (end - start > 2) {\n                new_text += \"-\" + text[i];\n            } else if (end - start > 0) {\n                new_text += \"_\".repeat(end - start) + text[i];\n            } else {\n                new_text += text[i];\n            }\n            start = i + 1;\n            end = i + 1;\n        }\n        i += 1;\n    }\n    if (end - start > 2) {\n        new_text += \"-\";\n    } else if (end - start > 0) {\n        new_text += \"_\";\n    }\n    return new_text;\n}\n",
  "141": "const fileNameCheck = (fileName) => {\n    const allowedExtensions = ['txt', 'exe', 'dll'];\n    const parts = fileName.split('.');\n    \n    if (parts.length !== 2) return 'No';\n    if (!allowedExtensions.includes(parts[1])) return 'No';\n    if (parts[0].length === 0) return 'No';\n    if (!isNaN(parts[0][0])) return 'No';\n    \n    const digitCount = parts[0].split('').filter(char => !isNaN(char)).length;\n    if (digitCount > 3) return 'No';\n    \n    return 'Yes';\n}\n\nconst check = (fileNameCheck) => {\n    assert(fileNameCheck(\"example.txt\") === 'Yes');\n    assert(fileNameCheck(\"1example.dll\") === 'No');\n    assert(fileNameCheck('s1sdf3.asd') === 'No');\n    assert(fileNameCheck('K.dll') === 'Yes');\n    assert(fileNameCheck('MY16FILE3.exe') === 'Yes');\n    assert(fileNameCheck('His12FILE94.exe') === 'No');\n    assert(fileNameCheck('_Y.txt') === 'No');\n    assert(fileNameCheck('?aREYA.exe') === 'No');\n    assert(fileNameCheck('/this_is_valid.dll') === 'No');\n    assert(fileNameCheck('this_is_valid.wow') === 'No');\n    assert(fileNameCheck('this_is_valid.txt') === 'Yes');\n    assert(fileNameCheck('this_is_valid.txtexe') === 'No');\n    assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No');\n    assert(fileNameCheck('@this1_is6_valid.exe') === 'No');\n    assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No');\n    assert(fileNameCheck('all.exe.txt') === 'No');\n    assert(fileNameCheck('I563_No.exe') === 'Yes');\n    assert(fileNameCheck('Is3youfault.txt') === 'Yes');\n    assert(fileNameCheck('no_one#knows.dll') === 'Yes');\n    assert(fileNameCheck('1I563_Yes3.exe') === 'No');\n    assert(fileNameCheck('I563_Yes3.txtt') === 'No');\n    assert(fileNameCheck('final..txt') === 'No');\n    assert(fileNameCheck('final132') === 'No');\n    assert(fileNameCheck('_f4indsartal132.') === 'No');\n    assert(fileNameCheck('.txt') === 'No');\n    assert(fileNameCheck('s.') === 'No');\n}\n\ncheck(fileNameCheck);\n",
  "142": "const sumSquares = (lst) => {\n\n  let result = []\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0) {\n      result.push(lst[i] ** 2)\n    } else if (i % 4 === 0 && i % 3 !== 0) {\n      result.push(lst[i] ** 3)\n    } else {\n      result.push(lst[i])\n    }\n  }\n\n  return result.reduce((a, b) => a + b, 0)\n}\n",
  "143": "const wordsInSentence = (sentence) => {\n\n  let newLst = [];\n  for (let word of sentence.split(\" \")) {\n    let flag = 0;\n    if (word.length == 1) {\n      flag = 1;\n    }\n    for (let i = 2; i < word.length; i++) {\n      if (word.length % i == 0) {\n        flag = 1;\n      }\n    }\n    if (flag == 0 || word.length == 2) {\n      newLst.push(word);\n    }\n  }\n  return newLst.join(\" \");\n}\n  ",
  "144": "const simplify = (x, n) => {\n  const [a, b] = x.split(\"/\");\n  const [c, d] = n.split(\"/\");\n  const numerator = parseInt(a) * parseInt(c);\n  const denom = parseInt(b) * parseInt(d);\n  if (numerator / denom === parseInt(numerator / denom)) {\n    return true;\n  }\n  return false;\n}\n",
  "145": "const orderByPoints = (nums) => {\n\n    const digitsSum = (n) => {\n        let neg = 1;\n        if (n < 0) {\n            n *= -1;\n            neg = -1;\n        }\n        n = Array.from(String(n), Number);\n        n[0] *= neg;\n        return n.reduce((acc, val) => acc + val, 0);\n    }\n\n    return nums.sort((a, b) => {\n        return digitsSum(a) - digitsSum(b);\n    });\n}\n",
  "146": "const specialFilter = (nums) => {\n\n    let count = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 10) {\n            const oddDigits = [1, 3, 5, 7, 9];\n            const numberAsString = nums[i].toString();\n            if (oddDigits.includes(parseInt(numberAsString[0])) && oddDigits.includes(parseInt(numberAsString[numberAsString.length - 1]))) {\n                count++;\n            }\n        }\n    }\n    return count;\n\n}\n",
  "147": "const getMaxTriples = (n) => {\n  let A = [];\n  for (let i = 1; i <= n; i++) {\n    A.push(i * i - i + 1);\n  }\n\n  let ans = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((A[i] + A[j] + A[k]) % 3 === 0) {\n          ans.push([A[i], A[j], A[k]]);\n        }\n      }\n    }\n  }\n  \n  return ans.length;\n}\n\n",
  "148": "const bf = (planet1, planet2) => {\n    const planetNames = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"];\n    \n    if (!planetNames.includes(planet1) || !planetNames.includes(planet2) || planet1 === planet2) {\n        return [];\n    }\n    \n    const planet1Index = planetNames.indexOf(planet1);\n    const planet2Index = planetNames.indexOf(planet2);\n    \n    if (planet1Index < planet2Index) {\n        return planetNames.slice(planet1Index + 1, planet2Index);\n    } else {\n        return planetNames.slice(planet2Index + 1, planet1Index);\n    }\n}\n",
  "149": "const sortedListSum = (lst) => {\n  lst.sort((a, b) => a.length - b.length);\n  const newList = lst.filter(item => item.length % 2 === 0);\n  return newList;\n}\n",
  "150": "const xOrY = (n, x, y) => {\n\n  if (n === 1) {\n    return y;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return y;\n      break;\n    }\n  }\n  return x;\n}\n",
  "151": "const doubleTheDifference = (lst) => {\n  return lst.reduce((acc, curr) => {\n    if (curr > 0 && curr % 2 !== 0 && !String(curr).includes('.')) {\n      return acc + curr ** 2;\n    } else {\n      return acc;\n    }\n  }, 0);\n}\n",
  "152": "const compare = (game, guess) => {\n    return game.map((item, index) => Math.abs(item - guess[index]));\n}\n",
  "153": "const strongestExtension = (className, extensions) => {\n\n  let strongExt = extensions[0]\n  let myVal = extensions[0].match(/[A-Z]/g).length - extensions[0].match(/[a-z]/g).length\n\n  for (let s of extensions) {\n    let val = s.match(/[A-Z]/g).length - s.match(/[a-z]/g).length\n    if (val > myVal) {\n        strongExt = s\n        myVal = val\n    }\n  }\n\n  let result = `${className}.${strongExt}`\n  return result\n}\n\n",
  "154": "const cycPatternCheck = (a, b) => {\n    const l = b.length;\n    const pat = b + b;\n    for (let i = 0; i < a.length - l + 1; i++) {\n        for (let j = 0; j < l + 1; j++) {\n            if (a.slice(i, i + l) === pat.slice(j, j + l)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n",
  "155": "const evenOddCount = (num) => {\n    let evenCount = 0;\n    let oddCount = 0;\n    for (let i of Math.abs(num).toString()) {\n        if (parseInt(i) % 2 === 0) {\n            evenCount++;\n        } else {\n            oddCount++;\n        }\n    }\n    return [evenCount, oddCount];\n}\n",
  "156": "const intToMiniRoman = (number) => {\n  const num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n  const sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"];\n  let i = 12;\n  let res = '';\n  \n  while (number) {\n    const div = Math.floor(number / num[i]);\n    number %= num[i];\n    \n    while (div) {\n      res += sym[i];\n      div--;\n    }\n    i--;\n  }\n  \n  return res.toLowerCase();\n}\n\n",
  "157": "js\nfunction rightAngleTriangle(a, b, c) {\n\n    return a*a === b*b + c*c || b*b === a*a + c*c || c*c === a*a + b*b;\n}\n",
  "158": "const findMax = (words) => {\n  return words.sort((a, b) => b.length - new Set(b).size - (a.length - new Set(a).size) || a.localeCompare(b))[0];\n}\n",
  "159": "const eat = (number, need, remaining) => {\n    if (need <= remaining) {\n        return [number + need, remaining - need];\n    } else {\n        return [number + remaining, 0];\n    }\n}\n",
  "160": "const doAlgebra = (operator, operand) => {\n\n  let expression = String(operand[0]);\n  for (let i = 0; i < operator.length; i++) {\n    expression += operator[i] + String(operand[i + 1]);\n  }\n  return eval(expression);\n}\n",
  "161": "const solve = (s) => {\n\n  let flg = 0;\n  let idx = 0;\n  let newStr = s.split('');\n  \n  newStr = newStr.map((char) => {\n    if (/^[a-zA-Z]*$/.test(char)) {\n      const swapped = char === char.toLowerCase() ? char.toUpperCase() : char.toLowerCase();\n      flg = 1;\n      return swapped;\n    }\n    return char;\n  });\n  \n  let result = newStr.join('');\n  \n  if (flg === 0) {\n    return result.split(\"\").reverse().join(\"\");\n  }\n  return result;\n}\n",
  "162": "const stringToMd5 = (text) => {\n    const crypto = require('crypto');\n    if (text) {\n        return crypto.createHash('md5').update(text, 'utf8').digest('hex');\n    } else {\n        return null;\n    }\n}\n\n",
  "163": "const generateIntegers = (a, b) => {\n    const lower = Math.max(2, Math.min(a, b));\n    const upper = Math.min(8, Math.max(a, b));\n    return Array.from({length: upper - lower + 1}, (_, i) => lower + i).filter(num => num % 2 === 0);\n}\n"
}