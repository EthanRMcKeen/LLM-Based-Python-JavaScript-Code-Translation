{
  "8": "def sum_product(numbers, int_arg):\n    sum_value = 0\n    prod_value = 1\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return [sum_value, prod_value]",
  "20": "def find_closest_elements(numbers):\n    closest_pair = None\n    distance = None\n    for i in range(len(numbers)):\n        for j in range(len(numbers)):\n            if i != j:\n                a = numbers[i]\n                b = numbers[j]\n                new_distance = abs(a - b)\n                if distance is None or new_distance < distance:\n                    distance = new_distance\n                    closest_pair = [min(a, b), max(a, b)]\n    return closest_pair",
  "66": "def digit_sum(s):\n    if s == '':\n        return 0\n    return sum(ord(char) if 65 <= ord(char) <= 90 else 0 for char in s)",
  "71": "import math\n\ndef triangle_area(a, b, c):\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    s = (a + b + c) / 2\n    area = math.pow(s * (s - a) * (s - b) * (s - c), 0.5)\n    area = \"{:.2f}\".format(area)\n    return area",
  "77": "import math\n\ndef is_cube(a):\n  a = abs(a)\n  return (round(math.pow(a, 1.0 / 3.0)) ** 3 == a)",
  "87": "def get_row(lst, x):\n    t = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i]) - 1, -1, -1):\n            if lst[i][j] == x:\n                t.append(i)\n                break\n    return t",
  "88": "def sort_array(array: list[int]) -> list[int]:\n    arr = array[:]\n    tot = arr[0] + arr[-1]\n    for j in range(len(arr)):\n        ind = j\n        for k in range(j + 1, len(arr)):\n            if (tot % 2 != 0 and arr[k] < arr[ind]) or (tot % 2 == 0 and arr[k] > arr[ind]):\n                ind = k\n        arr[j], arr[ind] = arr[ind], arr[j]\n    return arr",
  "90": "from typing import List, Optional\n\n\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    if not lst:\n        return None\n    smallest = float('inf')\n    next_smallest_val = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            next_smallest_val = smallest\n            smallest = num\n        elif smallest < num < next_smallest_val:\n            next_smallest_val = num\n\n    if next_smallest_val == float('inf'):\n        return None\n    else:\n        return next_smallest_val",
  "95": "def check_dict_case(dict):\n    c = 0\n    lo = 1\n    hi = 1\n    for key in dict:\n        c += 1\n        for i in range(len(key)):\n            if ord(key[i]) < 65 or ord(key[i]) > 90:\n                hi = 0\n            if ord(key[i]) < 97 or ord(key[i]) > 122:\n                lo = 0\n    if (lo == 0 and hi == 0) or c == 0:\n        return False\n    return True",
  "99": "import math\n\ndef closest_integer(value):\n    value = float(value)\n    t = value % 1\n    if t < 0.5 and t > -0.5:\n        value -= t\n    else:\n        if value > 0:\n            value = math.ceil(value)\n        else:\n            value = math.floor(value)\n    return value",
  "103": "def rounded_avg(n, m):\n  if n > m:\n    return -1\n  k = (n + m) / 2\n  if k % 1 != 0:\n    k = (n + m + 1) / 2\n  return '0b' + bin(int(k))[2:]",
  "112": "def reverse_delete(s, c):\n    t = ''\n    for i in range(len(s)):\n        y = 1\n        for j in range(len(c)):\n            if s[i] == c[j]:\n                y = 0\n                break\n        if y == 1:\n            t += s[i]\n    z = 1\n    for i in range(len(t) // 2):\n        if t[i] != t[len(t) - i - 1]:\n            z = 0\n            break\n    if z == 0:\n        return False\n    return True",
  "114": "def min_sub_array_sum(nums: list):\n    min_val = nums[0]\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums) + 1):\n            s = sum(nums[i:j])\n            if s < min_val:\n                min_val = s\n    return min_val",
  "120": "def maximum(arr, k):\n    p = arr[:]\n    for j in range(len(p)):\n        ind = j\n        for l in range(j + 1, len(p)):\n            if p[l] > p[ind]:\n                ind = l\n        if ind > j:\n            tmp = p[j]\n            p[j] = p[ind]\n            p[ind] = tmp\n    if k == 0:\n        return []\n    return p[:k]",
  "129": "def min_path(grid, k):\n    m = 0\n    n = 0\n    found = False\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == 1:\n                m = i\n                n = j\n                found = True\n                break\n        if found:\n            break\n\n    min_val = float('inf')\n    if found:\n        if m > 0:\n            min_val = min(min_val, grid[m - 1][n])\n        if n > 0:\n            min_val = min(min_val, grid[m][n - 1])\n        if m < len(grid) - 1:\n            min_val = min(min_val, grid[m + 1][n])\n        if n < len(grid[0]) - 1:\n            min_val = min(min_val, grid[m][n + 1])\n\n    p = []\n    for i in range(k):\n        if i % 2 == 0:\n            p.append(1)\n        else:\n            p.append(0 if min_val == float('inf') else min_val)\n    return p",
  "146": "def special_filter(nums):\n    p = 0\n    for i in range(len(nums)):\n        if nums[i] < 10:\n            continue\n        y = str(nums[i])\n        if int(y[0]) % 2 == 1 and int(y[-1]) % 2 == 1:\n            p += 1\n    return p",
  "148": "def bf(planet1, planet2):\n    y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    u = []\n    lo = -1\n    hi = -1\n    for i in range(8):\n        if y[i] == planet1:\n            lo = i\n    for i in range(8):\n        if y[i] == planet2:\n            hi = i\n    if lo == -1 or hi == -1 or lo == hi:\n        return []\n    if lo > hi:\n        tmp = lo\n        lo = hi\n        hi = tmp\n    for i in range(lo + 1, hi):\n        u.append(y[i])\n    return u",
  "153": "def strongest_extension(class_name, extensions):\n    u = 0\n    s = float('-inf')\n    for i in range(len(extensions)):\n        y = 0\n        for j in range(len(extensions[i])):\n            k = ord(extensions[i][j])\n            if 65 <= k <= 90:\n                y += 1\n            if 97 <= k <= 122:\n                y -= 1\n        if y >= s:\n            s = y\n            u = i\n    return class_name + '.' + extensions[u]",
  "155": "def even_odd_count(num: int) -> tuple[int, int]:\n    \"\"\"\n    Counts the number of even and odd digits in a given integer.\n\n    Args:\n        num: The integer to analyze.\n\n    Returns:\n        A tuple containing the count of even digits and the count of odd digits, respectively.\n    \"\"\"\n    odd_count = 0\n    even_count = 0\n    if num < 0:\n        num = -num\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num //= 10\n    return even_count, odd_count"
}