{
  "8": "\n```python\ndef sum_product(numbers, int_arg):\n    sum_value = 0\n    prod_value = 1\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return [sum_value, prod_value]",
  "20": "def find_closest_elements(numbers):\n    \"\"\"\n    Finds the pair of numbers in a list with the smallest absolute difference.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        A list containing the closest pair of numbers [smaller, larger], or None if the input list has fewer than 2 elements.\n    \"\"\"\n    if len(numbers) < 2:\n        return None  # Handle edge case: not enough numbers to form a pair\n\n    closest_pair = None\n    distance = float('inf')  # Initialize distance to infinity\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):  # Iterate only over unique pairs\n            a = numbers[i]\n            b = numbers[j]\n            new_distance = abs(a - b)\n\n            if new_distance < distance:\n                distance = new_distance\n                closest_pair = [min(a, b), max(a, b)]\n\n    return closest_pair",
  "23": "def strlen(string):\n  return len(string)",
  "57": "def is_monotonic(l):\n    increasing = all(l[i] <= l[i+1] for i in range(len(l)-1))\n    decreasing = all(l[i] >= l[i+1] for i in range(len(l)-1))\n    return increasing or decreasing\n```",
  "66": "def digit_sum(s):\n    if not s:\n        return 0\n    return sum(ord(char) if 65 <= ord(char) <= 90 else 0 for char in s)",
  "71": "import math\n\ndef triangle_area(a, b, c):\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return float(f\"{area:.2f}\")\n```\n\n**Reasoning for Corrections:**\n\nThe two errors in the previous Python code were:\n\n1.  **Incorrect use of `math.pow`**: While `math.pow(x, 0.5)` is valid for calculating the square root, `math.sqrt(x)` is more efficient and semantically clearer for this purpose. The second attempt correctly replaced `math.pow` with `math.sqrt`.\n\n2.  **Incorrect Type Conversion**: The original Javascript returns a string, but the second attempt converts the result to a `float`. The corrected code uses an f-string with the `:.2f` format specifier to format the `area` to two decimal places, similar to `toFixed(2)` in JavaScript. This ensures the result is a string, matching the behavior of the JavaScript code. The converted result is then converted to a float.",
  "77": "import math\n\ndef is_cube(a):\n    a = abs(a)\n    return round(a**(1/3))**3 == a\n```",
  "87": "def get_row(lst, x):\n    t = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i]) - 1, -1, -1):\n            if lst[i][j] == x:\n                t.append((i, j))\n    return t\n```\n\n**Explanation of Errors and Corrections:**\n\nThe first attempt's primary error was that it only appended `i` to the `t` list and had a break statement, which prematurely exited the inner loop after the first match in a row.  The original JavaScript code intends to find *all* occurrences of `x` within the nested lists and store their row and column indices.  It should append a tuple of `(i, j)` representing the row and column. The `break` statement prevents finding all occurrences.\n\nThe second attempt correctly appends the tuple `(i, j)` to the list `t`.  This matches the intended behavior of the javascript code.  Therefore, the second attempt is the correct translation.",
  "88": "def sort_array(array):\n    arr = array[:]\n    tot = arr[0] + arr[len(arr) - 1]\n    for j in range(len(arr)):\n        ind = j\n        for k in range(j + 1, len(arr)):\n            if (tot % 2 != 0 and arr[k] < arr[ind]) or (tot % 2 == 0 and arr[k] > arr[ind]):\n                ind = k\n        tmp = arr[j]\n        arr[j] = arr[ind]\n        arr[ind] = tmp\n    return arr\n```\n\n**Reasoning for the corrections:**\n\n1. **Odd Number Check:**  The original JavaScript code uses `tot % 2 == 1` to check if `tot` is odd.  In Python, the equivalent is `tot % 2 != 0`.  The first two attempts retained `tot % 2 == 1`, which is syntactically correct but logically wrong for checking if the number is odd.\n\n2. **Second `arr[k] < arr[ind]` Correction:** The second attempt incorrectly changed the `arr[k] > arr[ind]` to `arr[k] < arr[ind]`, which changes the functionality of the code instead of correcting an error. The original JavaScript code uses `arr[k] > arr[ind]` when tot is even to sort in descending order, and this is the correct implementation.",
  "90": "def next_smallest(lst):\n    if not lst:\n        return None\n\n    smallest = float('inf')\n    next_smallest_val = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            next_smallest_val = smallest\n            smallest = num\n        elif num < next_smallest_val and num != smallest:\n            next_smallest_val = num\n\n    if next_smallest_val == float('inf'):\n        return None\n    else:\n        return next_smallest_val",
  "95": "def check_dict_case(dict):\n    c = 0\n    lo = 1\n    hi = 1\n    for key in dict:\n        c += 1\n        for i in range(len(key)):\n            if ord(key[i]) < 65 or ord(key[i]) > 90:\n                hi = 0\n            if ord(key[i]) < 97 or ord(key[i]) > 122:\n                lo = 0\n    if (lo == 0 and hi == 0) or c == 0:\n        return False\n    if (lo == 1 and hi == 1):\n        return False\n    return True",
  "99": "import math\n\ndef closest_integer(value):\n  value = float(value)\n  return math.floor(value + 0.5) if value >= 0 else math.ceil(value - 0.5)",
  "103": "import math\n\ndef rounded_avg(n, m):\n    if n > m:\n        return -1\n    k = (n + m) / 2\n    if k % 1 != 0:\n        k = math.floor((n + m) / 2)\n    return '0b' + bin(int(k))[2:]\n```\n\n**Reasoning for Corrections:**\n\n1. **Incorrect `k` calculation when `k` is not an integer:** The original JavaScript code intends to round *down* to the nearest integer when `k` has a fractional part *before* converting to binary.  The incorrect Python code attempts to *round up* by adding 1 to n+m before dividing. The prompt asked for corrections to the python translation, not to change the behaviour of the code.  The `math.floor()` function is used to correctly round down to the nearest integer.\n\nWith this correction, the Python code now accurately mirrors the behavior of the original JavaScript code.  The rest of the translation (conditional check, binary conversion) was already correct.",
  "112": "def reverse_delete(s, c):\n    t = ''\n    for i in range(len(s)):\n        y = 1\n        for j in range(len(c)):\n            if s[i] == c[j]:\n                y = 0\n                break  # Add break to optimize inner loop\n        if y == 1:\n            t += s[i]\n    z = 1\n    for i in range(len(t) // 2):  # Only iterate through half the string\n        if t[i] != t[len(t) - i - 1]:\n            z = 0\n            break  # Add break to optimize inner loop\n    if z == 0:\n        return False\n    return True\n```\n\n**Reasoning for Corrections:**\n\nThe original and the first two attempted Python translations had logical errors, even though they produced the same outputs for many test cases.  Here's a breakdown of the issues and the corrections:\n\n1. **Unnecessary Full Iteration in Palindrome Check:** The palindrome check (the second loop involving `z`) was iterating through the *entire* string `t`.  For a palindrome check, you only need to iterate through *half* the string. If the first half matches the reversed second half, it's a palindrome.  Iterating through the entire string just repeats the comparisons unnecessarily and is less efficient.  The corrected code changes the range to `range(len(t) // 2)`.\n\nWith this change, the code functions identically to the Javascript, and the errors have been corrected.",
  "114": "def min_sub_array_sum(nums):\n    if not nums:\n        return 0  # Handle empty array case\n\n    min_so_far = float('inf')  # Initialize with positive infinity\n\n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            min_so_far = min(min_so_far, current_sum)\n\n    return min_so_far",
  "129": "def min_path(grid, k):\n    m = 0\n    n = 0\n    rows = len(grid)\n    \n    found = False\n    for i in range(rows):\n        cols = len(grid[i])\n        for j in range(cols):\n            if grid[i][j] == 1:\n                m = i\n                n = j\n                found = True\n                break\n        if found:\n            break\n\n    min_val = rows * rows  # Corrected initialization\n\n    if rows > 0:\n      cols = len(grid[0]) if rows > 0 else 0\n      if m > 0 and m < rows and n < cols and grid[m - 1][n] < min_val:\n          min_val = grid[m - 1][n]\n      if n > 0 and m < rows and n < cols and grid[m][n - 1] < min_val:\n          min_val = grid[m][n - 1]\n      if m < rows - 1 and m < rows and n < cols and grid[m + 1][n] < min_val:\n          min_val = grid[m + 1][n]\n      if n < cols - 1 and m < rows and n < cols and grid[m][n + 1] < min_val:\n          min_val = grid[m][n + 1]\n\n    p = []\n    for i in range(k):\n        if i % 2 == 0:\n            p.append(1)\n        else:\n            p.append(min_val)\n    return p\n```\n\n**Corrections and Explanation:**\n\n1. **Initialization of `min_val`:** The original JavaScript code initializes `min` to `grid.length * grid.length`. The Python code should do the same.  The previous attempts used `rows * cols` which is incorrect because the JS code is multiplying `grid.length` by itself.  In the case of a non-square grid, this would produce an incorrect initial value.\n",
  "146": "def special_filter(nums):\n    p = 0\n    for i in range(len(nums)):\n        if nums[i] < 10:\n            continue\n        y = str(nums[i])\n        if int(y[0]) % 2 == 1 and int(y[-1]) % 2 == 1:\n            p += 1\n    return p",
  "148": "def bf(planet1, planet2):\n    y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    u = []\n    lo = -1\n    hi = -1\n    for i in range(8):\n        if y[i] == planet1:\n            lo = i\n    for i in range(8):\n        if y[i] == planet2:\n            hi = i\n    if lo == -1 or hi == -1 or lo == hi:\n        return []\n    if lo > hi:\n        tmp = lo\n        lo = hi\n        hi = tmp\n    for i in range(lo + 1, hi):\n        u.append(y[i])\n    return u",
  "153": "def strongest_extension(class_name, extensions):\n    u = 0\n    s = float('-inf')\n    for i in range(len(extensions)):\n        y = 0\n        for j in range(len(extensions[i])):\n            k = ord(extensions[i][j])\n            if 65 <= k <= 90:\n                y += 1\n            if 97 <= k <= 122:\n                y -= 1\n        if y > s:\n            s = y\n            u = i\n    return class_name + '.' + extensions[u]",
  "155": "def even_odd_count(num):\n    o = 0\n    e = 0\n    if num < 0:\n        num = -num\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            e += 1\n        else:\n            o += 1\n        num //= 10\n    return e, o\n```\n\n**Corrections and Explanations:**\n\nThe first incorrect attempt had a logic error in how it extracted digits. `num = (num - num % 10) // 10` correctly isolates the last digit (`num % 10`) and then removes it from the number. The floor division `//` is used to ensure an integer result, mirroring the behavior of JavaScript's division in this context.\n\nThe second incorrect attempt had no logic errors but had an error in the return. The Javascript code `return (e, o)` returns a tuple, but the first incorrect translation returned `return (e,o)` which is interpreted as returning `o` and ignoring `e`. The corrected code returns `e, o` which is the proper way to return a tuple in Python."
}